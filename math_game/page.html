<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>And it goes brr..</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.cdnfonts.com/css/fixedsys-excelsior-301" rel="stylesheet">
</head>
<body>
    <div class="top-bar">
        <a href="../index.html" class="back-link">‚Üê back</a>
        <span class="game-title">Computation Factory</span>
        <div class="settings-btn" id="settingsBtn" title="Settings">‚öô</div>
    </div>
    
    <div class="era-banner" id="eraBanner">
        <span class="era-name" id="eraName">MENTAL ERA</span>
    </div>
    
    <div class="news-bar hidden">
        <span class="news-text"></span>
    </div>
    
    <div class="settings-panel hidden" id="settingsPanel">
        <div class="settings-header">Settings</div>
        <button class="settings-option reset-btn" id="resetBtn">üóë Reset Game</button>
        <button class="settings-close" id="settingsClose">‚úï</button>
    </div>
    
    <div class="confirm-modal hidden" id="confirmModal">
        <div class="confirm-box">
            <div class="confirm-text">Are you sure you want to reset?<br>All progress will be lost!</div>
            <div class="confirm-buttons">
                <button class="confirm-yes" id="confirmYes">Yes, Reset</button>
                <button class="confirm-no" id="confirmNo">Cancel</button>
            </div>
        </div>
    </div>
    
    <div class="stage-flash hidden" id="stageFlash"></div>
    <div class="opm-flash hidden" id="opmFlash"></div>
    
    <div class="bonus-problem-popup hidden" id="bonusProblem">
        <div class="bonus-header">‚ö° BONUS ‚ö°</div>
        <div class="bonus-timer" id="bonusTimer">20s</div>
        <div class="bonus-reward" id="bonusReward">???</div>
        <div class="bonus-input-row">
            <span class="bonus-text" id="bonusProblemText">99 √ó 99 =</span>
            <input type="text" class="bonus-input" id="bonusInput" autocomplete="off">
        </div>
    </div>
    
    <div class="active-effects" id="activeEffects"></div>
    
    <div class="main-content">
        <div class="left-panel">
            <div class="complexity-display">
                <div class="bit-display" id="bitDisplay">2-bit</div>
                <div class="stage-progress">
                    <div class="stage-fill" id="stageFill"></div>
                </div>
                <div class="stage-next" id="stageNext">next: 100</div>
            </div>
            
            <div class="stats-section">
                <div class="stat-row">
                    <span class="stat-name">solved</span>
                    <span class="stat-val" id="totalSolved">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-name">flops/m</span>
                    <span class="stat-val" id="flopsDisplay">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-name">bonus</span>
                    <span class="stat-val" id="bonusSolved">0</span>
                </div>
            </div>
            
            <div class="complexity-section">
                <div class="symbol-flicker" id="symbolFlicker">01</div>
            </div>
        </div>
        
        <div class="game-box" id="gameBox">
            <div class="computations-display">
                <span class="comp-value" id="computations">0</span>
                <span class="comp-label">computations</span>
                <span class="comp-rate" id="compRate">+0.0/sec</span>
            </div>
            
            <div class="problem-area">
                <div class="problem-stack">
                    <div class="input-row" id="inputRow">
                        <span class="problem-text" id="problemText">1 + 1 =</span>
                        <input type="text" class="answer-input" id="answerInput" autocomplete="off">
                    </div>
                    <div class="matrix-input-area hidden" id="matrixInputArea"></div>
                    <div class="queue-list" id="queueList"></div>
                </div>
            </div>
            
            <div class="streak-bar">
                <div class="streak-fill" id="streakFill"></div>
            </div>
        </div>
    </div>
    
    <div class="shop-panel">
        <div class="shop-section facilities-section">
            <div class="section-header">FACILITIES</div>
            <div class="section-content" id="facilitiesTab"></div>
        </div>
        <div class="shop-section upgrades-section">
            <div class="section-header">UPGRADES</div>
            <div class="section-content" id="upgradesTab"></div>
        </div>
    </div>
    
    <div class="pets-container" id="petsContainer"></div>

    <script>
        let CONFIG = {};
        
        async function loadConfig() {
            const response = await fetch('config.json');
            CONFIG = await response.json();
            initGame();
        }
        
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playBeep(freq, dur) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = freq;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            osc.start();
            osc.stop(audioCtx.currentTime + dur);
        }
        
        function playCorrect() { playBeep(CONFIG.audio.beepFrequency, CONFIG.audio.beepDuration); }
        function playBonus() { 
            playBeep(CONFIG.audio.bonusBeepFrequency, CONFIG.audio.bonusBeepDuration);
            setTimeout(() => playBeep(CONFIG.audio.bonusBeepFrequency * 1.5, CONFIG.audio.bonusBeepDuration), 100);
        }
        function playStageUp() {
            playBeep(CONFIG.audio.stageUpFrequency, CONFIG.audio.stageUpDuration);
            setTimeout(() => playBeep(CONFIG.audio.stageUpFrequency * 1.25, CONFIG.audio.stageUpDuration), 150);
            setTimeout(() => playBeep(CONFIG.audio.stageUpFrequency * 1.5, CONFIG.audio.stageUpDuration * 1.5), 300);
        }
        function playPurchase() { playBeep(380, 0.08); }
        
        let queue = [], currentProblem = null;
        let computations = 0, totalSolved = 0, bonusSolved = 0;
        let currentEra = 1, complexityLevel = 1;
        let lastSaveTime = Date.now();
        let facilities = {}, upgrades = {};
        
        let stats = {
            playTime: 0, offlineTime: 0, totalSolved: 0,
            arithSolved: 0, probSolved: 0, matrixSolved: 0,
            hackSurvived: 0, hackPerfect: 0, bonusSolved: 0, bonusPerfect: 0,
            streak: 0, startTime: Date.now(), wrongAnswers: 0,
            eraTime: { 1: 0, 2: 0, 3: 0, 4: 0 }
        };
        
        let pets = {};
        
        let facilityBoostActive = false, facilityBoostEnd = 0;
        let solveBoostActive = false, solveBoostEnd = 0;
        let nextBonusTime = 0, bonusProblemData = null, bonusEndTime = 0;
        
        let hackActive = false, hackEndTime = 0, hackQueue = 0, hackProblem = null;
        let hackSolved = 0, hackSpeedLevel = 0, hackInterval = null, hackSpeedInterval = null;
        let lastHackTime = 0;
        
        let newsIndex = 0, lastNewsChange = 0;
        const NEWS_CHANGE_INTERVAL = 45000;
        
        let solveTimestamps = [];
        let matrixInputs = [];
        let currentInputIndex = 0;
        let lastOpmTier = 0;
        
        const FLOP_COUNTS = [
            1, 1, 1, 2, 2, 3, 2, 4, 3, 4,
            3, 5, 5, 8, 10, 5, 1, 1, 1, 1,
            2, 2, 8, 10, 5, 3, 6, 10, 10, 16,
            8, 8, 7, 7, 15, 6, 18, 6, 30, 24,
            30, 24, 80, 60, 20, 90, 250, 300, 160, 60,
            100, 200, 5, 80, 20, 30, 20, 40, 45, 10
        ];
        
        const digits = '0123456789';
        const symbols1 = '#?%&@!*^~';
        const symbols2 = '‚àë‚àè‚à´‚àöœÄŒî‚àÇŒª‚àû‚âà‚â†¬±√ó√∑';
        const symbols3 = 'Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæœÄœÅœÉœÑœÖœÜœáœàœâ';
        const angelicGlyphs = '‚Ñµ‚Ñ∂‚Ñ∑‚Ñ∏‚Ñ©‚ÑÆ‚ÑØ‚Ñ∞‚Ñ±‚Ñ≤‚Ñ≥‚Ñ¥◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊õ◊ú◊û◊†◊°◊¢◊§◊¶◊ß◊®◊©◊™';
        
        function getEraName() {
            const names = ['Mental', 'Analog', 'Digital', 'Cosmic'];
            return names[currentEra - 1];
        }
        
        function getComplexityThreshold(level) {
            if (level <= 1) return 0;
            let total = 0;
            let increment = CONFIG.complexityUnlock.baseProblems;
            for (let i = 2; i <= level; i++) {
                total += Math.floor(increment);
                increment *= CONFIG.complexityUnlock.growthRate;
            }
            return total;
        }
        
        function calculateComplexityLevel() {
            let level = 1;
            while (level < 60 && totalSolved >= getComplexityThreshold(level + 1)) level++;
            return level;
        }
        
        function getEraFacilities(era) {
            return Object.entries(CONFIG.facilities).filter(([k, v]) => v.era === era).map(([k]) => k);
        }
        
        function checkEraUnlock() {
            const eraFacs = getEraFacilities(currentEra);
            const allOwned = eraFacs.every(k => facilities[k].owned >= 1);
            if (allOwned && currentEra < 4) {
                currentEra++;
                playStageUp();
                showStageFlash();
                updateVisualFlair();
                return true;
            }
            return false;
        }
        
        function getNewsBank() {
            if (currentEra < 2) return null;
            if (currentEra === 2) {
                if (complexityLevel <= 20) return CONFIG.newsHeadlines.era2_early;
                if (complexityLevel <= 35) return CONFIG.newsHeadlines.era2_mid;
                return CONFIG.newsHeadlines.era2_late;
            }
            if (currentEra === 3) {
                if (complexityLevel <= 25) return CONFIG.newsHeadlines.era3_early;
                if (complexityLevel <= 40) return CONFIG.newsHeadlines.era3_mid;
                return CONFIG.newsHeadlines.era3_late;
            }
            if (complexityLevel <= 25) return CONFIG.newsHeadlines.era4_early;
            if (complexityLevel <= 45) return CONFIG.newsHeadlines.era4_mid;
            return CONFIG.newsHeadlines.era4_late;
        }
        
        function initGame() {
            Object.keys(CONFIG.facilities).forEach(k => { facilities[k] = { owned: 0 }; });
            Object.keys(CONFIG.upgrades).forEach(k => { upgrades[k] = { owned: false }; });
            Object.keys(CONFIG.pets).forEach(k => { pets[k] = { owned: false }; });
            
            buildShopUI();
            loadGame();
            complexityLevel = calculateComplexityLevel();
            scheduleNextBonus();
            scheduleNextHack();
            fillQueue();
            updateVisualFlair();
            updateDisplay();
            document.getElementById('answerInput').focus();
            
            setInterval(gameTick, CONFIG.tickIntervalMs);
            setInterval(saveGame, CONFIG.saveIntervalMs);
            startComplexityFlicker();
            setupDebugClicks();
        }
        
        function startComplexityFlicker() {
            const rate = getFlickerRate();
            updateSymbolFlicker();
            setTimeout(startComplexityFlicker, rate);
        }
        
        function getFlickerRate() {
            const maxRate = 1000;
            const minRate = 40;
            const progress = Math.min(complexityLevel / 60, 1);
            return Math.floor(maxRate - (maxRate - minRate) * progress);
        }
        
        function updateSymbolFlicker() {
            const el = document.getElementById('symbolFlicker');
            const level = complexityLevel;
            
            let gridSize, glyphSet;
            if (level <= 20) {
                gridSize = 2;
            } else if (level <= 40) {
                gridSize = 3;
            } else {
                gridSize = 4;
            }
            
            if (level <= 10) {
                glyphSet = digits;
            } else if (level <= 20) {
                glyphSet = digits + symbols1;
            } else if (level <= 30) {
                glyphSet = symbols1 + symbols2;
            } else if (level <= 40) {
                glyphSet = symbols2 + symbols3;
            } else if (level <= 50) {
                glyphSet = symbols3 + angelicGlyphs.slice(0, 20);
            } else {
                glyphSet = angelicGlyphs + symbols2 + symbols3;
            }
            
            let colorPool = ['#aaa'];
            if (currentEra >= 2 || level >= 15) {
                colorPool.push('#ff9f43', '#ffa502');
            }
            if (currentEra >= 3 || level >= 30) {
                colorPool.push('#74b9ff', '#81ecec', '#00cec9');
            }
            if (currentEra >= 4 || level >= 45) {
                colorPool = ['#ff6b6b', '#ff9ff3', '#feca57', '#48dbfb', '#1dd1a1', '#5f27cd', '#ff9f43', '#00d2d3', '#54a0ff', '#c8d6e5'];
            }
            
            let content = '<div class="flicker-matrix grid-' + gridSize + '">';
            for (let i = 0; i < gridSize * gridSize; i++) {
                const glyph = glyphSet[Math.floor(Math.random() * glyphSet.length)];
                const color = colorPool[Math.floor(Math.random() * colorPool.length)];
                const useGlow = level >= 10 || currentEra >= 2;
                if (useGlow) {
                    content += '<span style="color:' + color + ';text-shadow:0 0 8px ' + color + '">' + glyph + '</span>';
                } else {
                    content += '<span style="color:' + color + '">' + glyph + '</span>';
                }
            }
            content += '</div>';
            
            if (level >= 25) {
                content += '<div class="sigil-particles"></div>';
            }
            if (level >= 40) {
                content += '<div class="sigil-particles-extra"></div>';
            }
            if (level >= 55) {
                content += '<div class="sigil-particles-intense"></div>';
            }
            
            el.innerHTML = content;
            
            const glowLevel = Math.floor(level / 10);
            el.className = 'symbol-flicker glow-' + glowLevel;
        }

        function scheduleNextHack() {
            if (currentEra < CONFIG.hackEvent.minEra || complexityLevel < CONFIG.hackEvent.minComplexity) {
                lastHackTime = Date.now() + 300000 + Math.random() * 120000;
            } else {
                lastHackTime = Date.now() + 240000 + Math.random() * 180000;
            }
        }
        
        function setupDebugClicks() {
            document.getElementById('settingsBtn').addEventListener('click', () => {
                document.getElementById('settingsPanel').classList.toggle('hidden');
            });
            
            document.getElementById('settingsClose').addEventListener('click', () => {
                document.getElementById('settingsPanel').classList.add('hidden');
            });
            
            document.getElementById('resetBtn').addEventListener('click', () => {
                document.getElementById('settingsPanel').classList.add('hidden');
                document.getElementById('confirmModal').classList.remove('hidden');
            });
            
            document.getElementById('confirmNo').addEventListener('click', () => {
                document.getElementById('confirmModal').classList.add('hidden');
            });
            
            document.getElementById('confirmYes').addEventListener('click', () => {
                resetGame();
                document.getElementById('confirmModal').classList.add('hidden');
            });
        }
        
        window.debug = {
            addComplexity: function(n = 1) {
                complexityLevel = Math.min(60, complexityLevel + n);
                updateVisualFlair();
                updateDisplay();
                saveGame();
                console.log('Complexity level:', complexityLevel);
            },
            addMoney: function(amount) {
                if (amount === undefined) {
                    computations = Math.max(computations * 2, 100);
                } else {
                    computations += amount;
                }
                updateDisplay();
                saveGame();
                console.log('Computations:', formatNumber(computations));
            },
            addEraTime: function(era, minutes = 30) {
                if (era < 1 || era > 4) {
                    console.log('Era must be 1-4');
                    return;
                }
                stats.eraTime[era] = (stats.eraTime[era] || 0) + (minutes * 60);
                saveGame();
                updateShopDisplay();
                console.log('Era', era, 'time:', Math.floor(stats.eraTime[era] / 60), 'minutes');
            },
            setEra: function(era) {
                if (era < 1 || era > 4) {
                    console.log('Era must be 1-4');
                    return;
                }
                currentEra = era;
                updateVisualFlair();
                updateDisplay();
                saveGame();
                console.log('Era set to:', era);
            },
            help: function() {
                console.log('=== DEBUG COMMANDS ===');
                console.log('debug.addComplexity(n)  - Add n complexity levels (default 1)');
                console.log('debug.addMoney(amount)  - Add computations (no arg = double current)');
                console.log('debug.addEraTime(era, minutes) - Add minutes to era timer (default 30)');
                console.log('debug.setEra(era)       - Set current era (1-4)');
                console.log('debug.help()            - Show this help');
            }
        };
        
        function resetGame() {
            localStorage.removeItem(CONFIG.saveKey);
            computations = 0;
            totalSolved = 0;
            bonusSolved = 0;
            currentEra = 1;
            complexityLevel = 1;
            Object.keys(facilities).forEach(k => { facilities[k].owned = 0; });
            Object.keys(upgrades).forEach(k => { upgrades[k].owned = false; });
            Object.keys(pets).forEach(k => { pets[k].owned = false; });
            stats = { playTime: 0, offlineTime: 0, totalSolved: 0, arithSolved: 0, probSolved: 0, matrixSolved: 0, hackSurvived: 0, hackPerfect: 0, bonusSolved: 0, bonusPerfect: 0, streak: 0, startTime: Date.now(), wrongAnswers: 0, eraTime: { 1: 0, 2: 0, 3: 0, 4: 0 } };
            renderPets();
            facilityBoostActive = false;
            solveBoostActive = false;
            hackActive = false;
            if (hackInterval) clearInterval(hackInterval);
            if (hackSpeedInterval) clearInterval(hackSpeedInterval);
            queue = [];
            currentProblem = null;
            solveTimestamps = [];
            lastOpmTier = 0;
            newsIndex = 0;
            lastNewsChange = 0;
            scheduleNextBonus();
            scheduleNextHack();
            fillQueue();
            updateVisualFlair();
            updateDisplay();
            document.getElementById('answerInput').focus();
        }
        
        function buildShopUI() {
            const facTab = document.getElementById('facilitiesTab');
            const upgTab = document.getElementById('upgradesTab');
            facTab.innerHTML = '';
            upgTab.innerHTML = '';
            
            Object.entries(CONFIG.facilities).forEach(([k, v]) => {
                const btn = document.createElement('button');
                btn.className = 'shop-item facility era-' + v.era;
                btn.id = 'buy_' + k;
                btn.disabled = true;
                btn.innerHTML = `
                    <div class="item-info">
                        <span class="item-name" id="name_${k}">${v.name}</span>
                        <span class="item-desc" id="desc_${k}">${v.desc}</span>
                        <span class="item-owned">√ó<span id="owned_${k}">0</span></span>
                    </div>
                    <span class="item-cost" id="cost_${k}">${formatNumber(v.basePrice)}</span>
                `;
                btn.addEventListener('click', () => buyFacility(k));
                facTab.appendChild(btn);
            });
            
            Object.entries(CONFIG.upgrades).forEach(([k, v]) => {
                const btn = document.createElement('button');
                btn.className = 'shop-item upgrade type-' + v.type;
                btn.id = 'buy_' + k;
                btn.disabled = true;
                btn.innerHTML = `
                    <div class="item-info">
                        <span class="item-name" id="uname_${k}">${v.name}</span>
                        <span class="item-desc" id="udesc_${k}">${v.desc}</span>
                    </div>
                    <span class="item-cost" id="ucost_${k}">${formatNumber(v.basePrice)}</span>
                `;
                btn.addEventListener('click', () => buyUpgrade(k));
                upgTab.appendChild(btn);
            });
            
            Object.entries(CONFIG.pets).forEach(([k, v]) => {
                pets[k] = pets[k] || { owned: false };
                const btn = document.createElement('button');
                btn.className = 'shop-item upgrade type-pet era-' + v.era;
                btn.id = 'buy_pet_' + k;
                btn.disabled = true;
                btn.innerHTML = `
                    <div class="item-info">
                        <span class="item-name" id="pname_${k}">${v.emoji} ${v.name}</span>
                        <span class="item-desc" id="pdesc_${k}">${v.desc}</span>
                    </div>
                    <span class="item-cost" id="pcost_${k}">${formatNumber(v.basePrice)}</span>
                `;
                btn.addEventListener('click', () => buyPet(k));
                upgTab.appendChild(btn);
            });
        }
        
        
        function gameTick() {
            stats.playTime += CONFIG.tickIntervalMs / 1000;
            stats.eraTime[currentEra] = (stats.eraTime[currentEra] || 0) + CONFIG.tickIntervalMs / 1000;
            computations += getComputationsPerSecond() / 10;
            
            if (facilityBoostActive && Date.now() > facilityBoostEnd) facilityBoostActive = false;
            if (solveBoostActive && Date.now() > solveBoostEnd) solveBoostActive = false;
            if (bonusProblemData && Date.now() > bonusEndTime) hideBonusProblem();
            if (!bonusProblemData && Date.now() > nextBonusTime) showBonusProblem();
            
            if (hackActive) {
                if (Date.now() > hackEndTime) endHackEvent(true);
            } else if (currentEra >= CONFIG.hackEvent.minEra && complexityLevel >= CONFIG.hackEvent.minComplexity && Date.now() > lastHackTime && !bonusProblemData) {
                startHackEvent();
            }
            
            updateNews();
            checkOpmFlair();
            updateDisplay();
        }
        
        function updateNews() {
            const bank = getNewsBank();
            const newsBar = document.querySelector('.news-bar');
            if (!newsBar) return;
            if (!bank) { newsBar.classList.add('hidden'); return; }
            newsBar.classList.remove('hidden');
            if (Date.now() - lastNewsChange > NEWS_CHANGE_INTERVAL) {
                newsIndex = (newsIndex + 1) % bank.length;
                lastNewsChange = Date.now();
            }
            const newsText = document.querySelector('.news-text');
            if (newsText) newsText.textContent = '‚ñ∏ ' + bank[newsIndex % bank.length];
        }
        
        function startHackEvent() {
            if (hackActive || currentEra < CONFIG.hackEvent.minEra || complexityLevel < CONFIG.hackEvent.minComplexity) return;
            hackActive = true;
            hackEndTime = Date.now() + CONFIG.hackEvent.durationMs;
            hackQueue = 0; hackSolved = 0; hackSpeedLevel = 0;
            generateHackProblem();
            hackInterval = setInterval(addHackThreat, getHackInterval());
            hackSpeedInterval = setInterval(increaseHackSpeed, CONFIG.hackEvent.speedIncreaseMs);
            playHackAlert();
        }
        
        function getHackInterval() {
            return Math.max(CONFIG.hackEvent.minIntervalMs, CONFIG.hackEvent.baseIntervalMs - hackSpeedLevel * CONFIG.hackEvent.intervalReduction);
        }
        
        function increaseHackSpeed() {
            if (!hackActive) return;
            hackSpeedLevel++;
            clearInterval(hackInterval);
            hackInterval = setInterval(addHackThreat, getHackInterval());
        }
        
        function addHackThreat() {
            if (!hackActive) return;
            hackQueue++;
            if (hackQueue >= CONFIG.hackEvent.maxQueue) endHackEvent(false);
        }
        
        function generateHackProblem() {
            const difficulty = Math.min(Math.floor((complexityLevel - 33) / 3), 8);
            let a, b, c, answer, text;
            switch(difficulty) {
                case 0: case 1: a = randRange(10, 99); b = randRange(10, 99); answer = a + b; text = `${a} + ${b} =`; break;
                case 2: case 3: a = randRange(10, 99); b = randRange(2, 9); answer = a * b; text = `${a} √ó ${b} =`; break;
                case 4: case 5: a = randRange(100, 999); b = randRange(100, 999); answer = a + b; text = `${a} + ${b} =`; break;
                default: a = randRange(10, 99); b = randRange(10, 99); answer = a * b; text = `${a} √ó ${b} =`; break;
            }
            hackProblem = { answer: String(answer), text };
        }
        
        function endHackEvent(success) {
            hackActive = false;
            clearInterval(hackInterval);
            clearInterval(hackSpeedInterval);
            if (success) {
                stats.hackSurvived++;
                if (hackQueue === 0) stats.hackPerfect++;
                const rewards = ['double', 'facility', 'solve'];
                const reward = rewards[Math.floor(Math.random() * rewards.length)];
                if (reward === 'double') computations *= 2;
                else if (reward === 'facility') { facilityBoostActive = true; facilityBoostEnd = Date.now() + 180000; }
                else { solveBoostActive = true; solveBoostEnd = Date.now() + 120000; }
                playBonus();
            } else {
                const penalty = CONFIG.hackEvent.penaltyMin + Math.random() * (CONFIG.hackEvent.penaltyMax - CONFIG.hackEvent.penaltyMin);
                computations *= (1 - penalty);
                playHackFail();
            }
            scheduleNextHack();
        }
        
        function playHackAlert() {
            playBeep(CONFIG.audio.hackAlertFrequency, 0.15);
            setTimeout(() => playBeep(CONFIG.audio.hackAlertFrequency * 1.25, 0.15), 100);
            setTimeout(() => playBeep(CONFIG.audio.hackAlertFrequency, 0.2), 200);
        }
        
        function playHackFail() {
            playBeep(CONFIG.audio.hackFailFrequency, 0.3);
            setTimeout(() => playBeep(CONFIG.audio.hackFailFrequency * 0.8, 0.3), 150);
            setTimeout(() => playBeep(CONFIG.audio.hackFailFrequency * 0.67, 0.4), 300);
        }
        
        function checkOpmFlair() {
            const flops = getFLOPS();
            const tiers = [10, 30, 60, 100, 150];
            let currentTier = 0;
            for (let i = 0; i < tiers.length; i++) {
                if (flops >= tiers[i]) currentTier = i + 1;
            }
            
            if (currentTier > lastOpmTier && currentTier > 0) {
                showOpmFlash(currentTier);
                document.body.classList.add('opm-boost-' + currentTier);
            } else if (currentTier < lastOpmTier) {
                for (let i = 1; i <= 5; i++) {
                    document.body.classList.remove('opm-boost-' + i);
                }
                if (currentTier > 0) document.body.classList.add('opm-boost-' + currentTier);
            }
            lastOpmTier = currentTier;
        }
        
        function showOpmFlash(tier) {
            const flash = document.getElementById('opmFlash');
            const msgs = ['', 'üî• 10 OPM!', '‚ö° 30 OPM!', 'üí´ 60 OPM!', 'ÔøΩÔøΩ 100 OPM!', 'üöÄ 150 OPM!'];
            flash.textContent = msgs[tier];
            flash.classList.remove('hidden');
            flash.classList.add('show');
            setTimeout(() => {
                flash.classList.remove('show');
                setTimeout(() => flash.classList.add('hidden'), 500);
            }, 1000);
        }
        
        function getFacilityMultiplier(facKey) {
            let mult = 1;
            Object.entries(upgrades).forEach(([k, v]) => {
                if (!v.owned) return;
                const cfg = CONFIG.upgrades[k];
                if (cfg.type === 'tiered' && cfg.facility === facKey) mult *= cfg.effect;
                if (cfg.type === 'synergy' && cfg.facility === facKey) {
                    const synergyCount = facilities[cfg.synergyWith]?.owned || 0;
                    mult *= (1 + cfg.effect * synergyCount);
                }
            });
            const facEra = CONFIG.facilities[facKey].era;
            if (upgrades['gen_era' + facEra]?.owned) mult *= 1.1;
            if (upgrades['gen_dedication']?.owned) mult *= 1.05;
            if (upgrades['gen_veteran']?.owned) mult *= 1.1;
            if (upgrades['gen_grand']?.owned) mult *= 1.25;
            if (upgrades['gen_million']?.owned) mult *= 1.5;
            if (upgrades['gen_full']?.owned) mult *= 1.2;
            if (upgrades['gen_egg_nothing']?.owned) mult *= 1.05;
            if (upgrades['gen_acausal']?.owned) mult *= 1.01;
            if (upgrades['gen_parfit']?.owned) mult *= 1.01;
            if (upgrades['gen_younger']?.owned) mult *= 1.02;
            if (upgrades['gen_demiurge']?.owned) mult *= 1.01;
            if (upgrades['gen_fermi']?.owned) mult *= 1.02;
            if (upgrades['gen_handshake']?.owned) mult *= 1.03;
            if (upgrades['gen_older']?.owned) mult *= 1.02;
            if (upgrades['gen_pristine']?.owned) mult *= 1.01;
            if (upgrades['gen_omnipotent']?.owned) mult *= 1.05;
            return mult;
        }
        
        function getComputationsPerSecond() {
            let base = 0;
            Object.entries(facilities).forEach(([k, v]) => {
                if (v.owned > 0 && CONFIG.facilities[k].era <= currentEra) {
                    base += v.owned * CONFIG.facilities[k].baseRate * getFacilityMultiplier(k);
                }
            });
            let globalMult = 1;
            if (facilityBoostActive) globalMult *= CONFIG.bonusProblem.effects.facilityBoost.multiplier;
            const flops = getFLOPS();
            const flopsMult = 0.05 + (flops / 15);
            return base * globalMult * flopsMult;
        }
        
        function getSolveValue() {
            let mult = 1;
            if (upgrades['gen_speed']?.owned) mult *= 1.1;
            if (upgrades['gen_math']?.owned) mult *= 1.15;
            if (upgrades['gen_error']?.owned) mult *= 1.05;
            if (currentProblem) {
                if (currentProblem.type === 'decimal' && upgrades['gen_decimal']?.owned) mult *= 1.15;
                if (currentProblem.text && currentProblem.text.includes('matrix') && upgrades['gen_matrix']?.owned) mult *= 1.15;
            }
            if (solveBoostActive) mult *= CONFIG.bonusProblem.effects.solveBoost.multiplier;
            const flopCount = currentProblem ? (FLOP_COUNTS[currentProblem.category] ?? 1) : 1;
            return flopCount * mult;
        }
        
        function getFLOPS() {
            const now = Date.now();
            const threeMinAgo = now - 180000;
            solveTimestamps = solveTimestamps.filter(entry => {
                if (typeof entry === 'number') return false;
                return entry.time > threeMinAgo;
            });
            const totalFlops = solveTimestamps.reduce((sum, entry) => sum + (entry.flops || 1), 0);
            return totalFlops / 3;
        }
        
        function scheduleNextBonus() {
            const minMs = 60000;
            const maxMs = 600000;
            nextBonusTime = Date.now() + minMs + Math.random() * (maxMs - minMs);
        }
        
        function showBonusProblem() {
            bonusProblemData = generateProblemForCategory(Math.min(complexityLevel - 1, 15));
            bonusEndTime = Date.now() + CONFIG.bonusProblem.durationMs;
            
            const effects = ['doubleComps', 'facilityBoost', 'solveBoost'];
            bonusProblemData.effect = effects[Math.floor(Math.random() * effects.length)];
            
            let rewardText = '';
            if (bonusProblemData.effect === 'doubleComps') rewardText = '2√ó comps';
            else if (bonusProblemData.effect === 'facilityBoost') rewardText = '5√ó speed 2min';
            else rewardText = '10√ó solve 1min';
            
            const popup = document.getElementById('bonusProblem');
            popup.style.left = (15 + Math.random() * 70) + '%';
            popup.style.top = (15 + Math.random() * 70) + '%';
            
            document.getElementById('bonusProblemText').textContent = bonusProblemData.text;
            document.getElementById('bonusReward').textContent = rewardText;
            popup.classList.remove('hidden');
            document.getElementById('bonusInput').value = '';
            document.getElementById('bonusInput').focus();
            
            playBonus();
        }
        
        function hideBonusProblem() {
            bonusProblemData = null;
            document.getElementById('bonusProblem').classList.add('hidden');
            document.getElementById('answerInput').focus();
            scheduleNextBonus();
        }
        
        function applyBonusEffect(effect) {
            if (effect === 'doubleComps') {
                computations *= 2;
            } else if (effect === 'facilityBoost') {
                facilityBoostActive = true;
                facilityBoostEnd = Date.now() + CONFIG.bonusProblem.effects.facilityBoost.durationMs;
            } else if (effect === 'solveBoost') {
                solveBoostActive = true;
                solveBoostEnd = Date.now() + CONFIG.bonusProblem.effects.solveBoost.durationMs;
            }
        }
        
        function checkComplexityUp() {
            const newLevel = calculateComplexityLevel();
            if (newLevel > complexityLevel) {
                complexityLevel = newLevel;
                if (complexityLevel % 5 === 0) showComplexityFlash();
            }
        }
        
        function showComplexityFlash() {
            const flash = document.getElementById('opmFlash');
            flash.textContent = '‚ö° COMPLEXITY ' + complexityLevel;
            flash.classList.remove('hidden', 'show'); 
            void flash.offsetWidth;
            flash.classList.add('show');
            setTimeout(() => { flash.classList.remove('show'); setTimeout(() => flash.classList.add('hidden'), 500); }, 1000);
        }
        
        function showStageFlash() {
            const flash = document.getElementById('stageFlash');
            flash.textContent = getEraName() + ' ERA UNLOCKED';
            flash.classList.remove('hidden', 'show');
            void flash.offsetWidth;
            flash.classList.add('show');
            setTimeout(() => { flash.classList.remove('show'); setTimeout(() => flash.classList.add('hidden'), 500); }, 1500);
        }
        
        function updateVisualFlair() {
            const body = document.body;
            body.className = 'era-' + currentEra;
            
            if (complexityLevel >= 10) body.classList.add('complexity-10-plus');
            if (complexityLevel >= 20) body.classList.add('complexity-20-plus');
            if (complexityLevel >= 30) body.classList.add('complexity-30-plus');
            if (complexityLevel >= 45) body.classList.add('complexity-45-plus');
            if (complexityLevel >= 55) body.classList.add('complexity-55-plus');
            
            const box = document.getElementById('gameBox');
            box.className = 'game-box era-' + currentEra;
        }
        
        function getPrice(base, mult, count) {
            return Math.floor(base * Math.pow(mult, count));
        }
        
        function formatNumber(n) {
            if (n >= 1e21) return (n / 1e21).toFixed(2) + 'Sx';
            if (n >= 1e18) return (n / 1e18).toFixed(2) + 'Qi';
            if (n >= 1e15) return (n / 1e15).toFixed(2) + 'Q';
            if (n >= 1e12) return (n / 1e12).toFixed(2) + 'T';
            if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
            if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
            if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
            return Math.floor(n).toLocaleString();
        }
        
        function formatBitComplexity(level) {
            if (level <= 3) return Math.pow(2, level - 1) + '-bit';
            if (level <= 13) return Math.pow(2, level - 4) + ' B';
            if (level <= 23) return Math.pow(2, level - 14) + ' KB';
            if (level <= 33) return Math.pow(2, level - 24) + ' MB';
            if (level <= 43) return Math.pow(2, level - 34) + ' GB';
            if (level <= 53) return Math.pow(2, level - 44) + ' TB';
            return Math.pow(2, level - 54) + ' PB';
        }
        
        function randRange(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function randSign() { return Math.random() < 0.5 ? 1 : -1; }
        function rand1or2d() { return Math.random() < 0.5 ? randRange(1, 9) : randRange(10, 99); }
        function randSignedElement() { return rand1or2d() * randSign(); }
        
        function generateProblemForCategory(cat) {
            let answer, text, type = 'simple';
            
            if (cat < 16) {
                return generateArithmeticProblem(cat);
            } else if (cat < 32) {
                return generateProbabilityProblem(cat - 16);
            } else if (cat < 51) {
                return generateLinearAlgebraProblem(cat - 32);
            } else {
                return generateMixedProblem(cat - 51);
            }
        }
        
        function generateArithmeticProblem(cat) {
            let a, b, c, answer, text;
            
            switch(cat) {
                case 0: 
                    a = randRange(1,9); b = randRange(1,9); 
                    answer = a+b; text = `${a} + ${b} =`; 
                    break;
                case 1: 
                    a = randRange(1,9); b = randRange(1, a);
                    answer = a-b; text = `${a} - ${b} =`; 
                    break;
                case 2: 
                    a = randRange(1,9); b = randRange(1,9); 
                    answer = a*b; text = `${a} √ó ${b} =`; 
                    break;
                case 3: 
                    a = randRange(10,99); b = randRange(10,99); 
                    answer = a+b; text = `${a} + ${b} =`; 
                    break;
                case 4: 
                    a = randRange(1,9); b = randRange(1,9); c = randRange(1,9);
                    if (Math.random() < 0.5) { answer = a+b-c; text = `${a} + ${b} - ${c} =`; }
                    else { answer = a-b+c; text = `${a} - ${b} + ${c} =`; }
                    break;
                case 5: 
                    a = randRange(1,9); b = randRange(10,99); 
                    if (Math.random() < 0.5) { answer = a*b; text = `${a} √ó ${b} =`; }
                    else { answer = b*a; text = `${b} √ó ${a} =`; }
                    break;
                case 6: 
                    b = randRange(2,9); answer = randRange(2,49); a = answer*b; 
                    text = `${a} √∑ ${b} =`; 
                    break;
                case 7: 
                    a = randRange(1,9); b = randRange(1,9); c = randRange(1,9);
                    const type = Math.floor(Math.random() * 4);
                    if (type === 0) { answer = a*b+c; text = `${a} √ó ${b} + ${c} =`; }
                    else if (type === 1) { answer = a*b-c; text = `${a} √ó ${b} - ${c} =`; }
                    else if (type === 2) { answer = a+b*c; text = `${a} + ${b} √ó ${c} =`; }
                    else { answer = a-b*c; text = `${a} - ${b} √ó ${c} =`; }
                    break;
                case 8: 
                    a = randRange(100,999); b = randRange(100,999); 
                    answer = a+b; text = `${a} + ${b} =`; 
                    break;
                case 9: 
                    a = randRange(1,9); b = randRange(100,999); 
                    if (Math.random() < 0.5) { answer = a*b; text = `${a} √ó ${b} =`; }
                    else { answer = b*a; text = `${b} √ó ${a} =`; }
                    break;
                case 10: 
                    a = randRange(100,999); b = randRange(100, a); 
                    answer = a-b; text = `${a} - ${b} =`; 
                    break;
                case 11: 
                    b = randRange(2,9); answer = randRange(100,999); a = answer*b; 
                    text = `${a} √∑ ${b} =`; 
                    break;
                case 12: 
                    a = randRange(1,9); b = randRange(10,99); c = randRange(1,9);
                    if (Math.random() < 0.5) {
                        let res = randRange(2, 20); b = randRange(2,9); a = res*b;
                        answer = res + c; text = `${a} √∑ ${b} + ${c} =`;
                    } else {
                        answer = a*b - c; text = `${a} √ó ${b} - ${c} =`;
                    }
                    break;
                case 13: 
                    a = randRange(10,99); b = randRange(10,99); 
                    answer = a*b; text = `${a} √ó ${b} =`; 
                    break;
                case 14: 
                    a = randRange(10,99); b = randRange(10,99); c = randRange(10,99);
                    const t = Math.floor(Math.random() * 3);
                    if (t === 0) { answer = a*b+c; text = `${a} √ó ${b} + ${c} =`; }
                    else if (t === 1) { answer = a+b*c; text = `${a} + ${b} √ó ${c} =`; }
                    else { answer = a+b+c; text = `${a} + ${b} + ${c} =`; }
                    break;
                case 15: 
                    a = randRange(1000,9999); b = randRange(1000,9999); 
                    answer = a+b; text = `${a} + ${b} =`; 
                    break;
                default: 
                    return generateArithmeticProblem(0);
            }
            return { answer: String(answer), text, type: 'simple', category: cat };
        }
        
        function generateProbabilityProblem(cat) {
            let answer, text;
            let a, b, c, pA, pB, pAB;
            
            switch(cat) {
                case 0:
                    a = randRange(1, 9) / 10;
                    b = randRange(1, 9) / 10;
                    answer = (a + b).toFixed(2).replace(/\.?0+$/, '');
                    if (answer.indexOf('.') === -1 && a + b < 1) answer = (a + b).toFixed(1);
                    text = `${a.toFixed(1)} + ${b.toFixed(1)} =`;
                    break;
                case 1:
                    a = randRange(2, 9) / 10;
                    b = randRange(1, Math.floor(a * 10)) / 10;
                    answer = (a - b).toFixed(2).replace(/\.?0+$/, '');
                    if (answer === '0') answer = '0';
                    text = `${a.toFixed(1)} - ${b.toFixed(1)} =`;
                    break;
                case 2:
                    a = randRange(1, 9) / 10;
                    b = randRange(1, 9) / 10;
                    answer = (a * b).toFixed(2);
                    text = `${a.toFixed(1)} √ó ${b.toFixed(1)} =`;
                    break;
                case 3:
                    a = randRange(2, 9) / 10;
                    b = randRange(1, 9) / 10;
                    while (b >= a) b = randRange(1, 9) / 10;
                    answer = (a / b).toFixed(2);
                    text = `${a.toFixed(1)} √∑ ${b.toFixed(1)} =`;
                    break;
                case 4:
                    a = randRange(10, 99) / 100;
                    b = randRange(10, 99) / 100;
                    answer = (a + b).toFixed(2);
                    text = `${a.toFixed(2)} + ${b.toFixed(2)} =`;
                    break;
                case 5:
                    a = randRange(10, 99) / 100;
                    b = randRange(10, Math.floor(a * 100)) / 100;
                    answer = (a - b).toFixed(2);
                    text = `${a.toFixed(2)} - ${b.toFixed(2)} =`;
                    break;
                case 6:
                    a = randRange(10, 99) / 100;
                    b = randRange(10, 99) / 100;
                    answer = (a * b).toFixed(2);
                    text = `${a.toFixed(2)} √ó ${b.toFixed(2)} =`;
                    break;
                case 7:
                    pA = randRange(1, 9) / 10;
                    pB = randRange(1, 9) / 10;
                    answer = (pA * pB).toFixed(2);
                    text = `A,B indep. P(A)=${pA.toFixed(1)}, P(B)=${pB.toFixed(1)}, P(A‚à©B)=`;
                    break;
                case 8:
                    pA = randRange(1, 4) / 10;
                    pB = randRange(1, 4) / 10;
                    answer = (pA + pB).toFixed(2).replace(/\.?0+$/, '');
                    text = `A,B disjoint. P(A)=${pA.toFixed(1)}, P(B)=${pB.toFixed(1)}, P(A‚à™B)=`;
                    break;
                case 9:
                    pA = randRange(10, 90) / 100;
                    answer = (1 - pA).toFixed(2);
                    text = `P(A)=${pA.toFixed(2)}, P(¬¨A)=`;
                    break;
                case 10:
                    pA = randRange(10, 50) / 100;
                    pB = randRange(10, 50) / 100;
                    pAB = randRange(5, Math.min(Math.floor(pA * 100), Math.floor(pB * 100))) / 100;
                    answer = ((pA + pB - pAB)).toFixed(2);
                    text = `P(A)=${pA.toFixed(2)}, P(B)=${pB.toFixed(2)}, P(A‚à©B)=${pAB.toFixed(2)}, P(A‚à™B)=`;
                    break;
                case 11:
                    pAB = randRange(10, 40) / 100;
                    pB = randRange(Math.floor(pAB * 100) + 10, 90) / 100;
                    answer = (pAB / pB).toFixed(2);
                    text = `P(A‚à©B)=${pAB.toFixed(2)}, P(B)=${pB.toFixed(2)}, P(A|B)=`;
                    break;
                case 12:
                    a = randRange(1, 9) / 10;
                    b = randRange(1, 9) / 10;
                    c = randRange(1, 9) / 10;
                    const op = Math.random() < 0.5 ? '+' : '-';
                    if (op === '+') {
                        answer = (a + b * c).toFixed(2);
                        text = `${a.toFixed(1)} + ${b.toFixed(1)} √ó ${c.toFixed(1)} =`;
                    } else {
                        answer = (a - b * c).toFixed(2);
                        text = `${a.toFixed(1)} - ${b.toFixed(1)} √ó ${c.toFixed(1)} =`;
                    }
                    break;
                case 13:
                    pA = randRange(1, 5) / 10;
                    const pBA = randRange(5, 9) / 10;
                    const pBnotA = randRange(1, 3) / 10;
                    const pB_total = pBA * pA + pBnotA * (1 - pA);
                    answer = ((pBA * pA) / pB_total).toFixed(2);
                    text = `P(A)=${pA.toFixed(1)}, P(B|A)=${pBA.toFixed(1)}, P(B|¬¨A)=${pBnotA.toFixed(1)}, P(A|B)=`;
                    break;
                case 14:
                    a = randRange(10, 99) / 100;
                    b = randRange(10, 99) / 100;
                    c = randRange(10, 99) / 100;
                    answer = (a * b + c).toFixed(2);
                    text = `${a.toFixed(2)} √ó ${b.toFixed(2)} + ${c.toFixed(2)} =`;
                    break;
                case 15:
                    a = randRange(10, 99) / 100;
                    b = randRange(10, Math.floor(a * 100)) / 100;
                    c = randRange(10, 99) / 100;
                    answer = ((a - b) * c).toFixed(2);
                    text = `(${a.toFixed(2)} - ${b.toFixed(2)}) √ó ${c.toFixed(2)} =`;
                    break;
                default:
                    return generateProbabilityProblem(0);
            }
            return { answer, text, type: 'decimal', category: cat + 16 };
        }
        
        function generateLinearAlgebraProblem(cat) {
            let answer, text, type = 'simple', inputCount = 1;
            
            const e = () => randSignedElement();
            
            switch(cat) {
                case 0: {
                    const a = e(), b = e(), c = e(), d = e();
                    answer = [a + c, b + d];
                    text = `[${a}, ${b}] + [${c}, ${d}] =`;
                    type = 'vector2';
                    inputCount = 2;
                    break;
                }
                case 1: {
                    const a = e(), b = e(), c = e(), d = e();
                    answer = [a - c, b - d];
                    text = `[${a}, ${b}] - [${c}, ${d}] =`;
                    type = 'vector2';
                    inputCount = 2;
                    break;
                }
                case 2: {
                    const k = randRange(2, 9) * randSign();
                    const a = e(), b = e();
                    answer = [k * a, k * b];
                    text = `${k} √ó [${a}, ${b}] =`;
                    type = 'vector2';
                    inputCount = 2;
                    break;
                }
                case 3: {
                    const a = e(), b = e(), c = e();
                    const d = e(), f = e(), g = e();
                    answer = [a + d, b + f, c + g];
                    text = `[${a}, ${b}, ${c}] + [${d}, ${f}, ${g}] =`;
                    type = 'vector3';
                    inputCount = 3;
                    break;
                }
                case 4: {
                    const k1 = randRange(1, 5) * randSign();
                    const k2 = randRange(1, 5) * randSign();
                    const a = e(), b = e(), c = e(), d = e();
                    answer = [k1 * a + k2 * c, k1 * b + k2 * d];
                    text = `${k1}[${a}, ${b}] + ${k2}[${c}, ${d}] =`;
                    type = 'vector2';
                    inputCount = 2;
                    break;
                }
                case 5: {
                    const k = randRange(2, 9) * randSign();
                    const a = e(), b = e(), c = e();
                    answer = [k * a, k * b, k * c];
                    text = `${k} √ó [${a}, ${b}, ${c}] =`;
                    type = 'vector3';
                    inputCount = 3;
                    break;
                }
                case 6: {
                    const a = e(), b = e(), c = e(), d = e();
                    answer = [a * c + b * d];
                    text = `[${a}, ${b}] ¬∑ [${c}, ${d}] =`;
                    type = 'simple';
                    break;
                }
                case 7: {
                    const a = e(), b = e(), c = e();
                    const d = e(), f = e(), g = e();
                    answer = [a - d, b - f, c - g];
                    text = `[${a}, ${b}, ${c}] - [${d}, ${f}, ${g}] =`;
                    type = 'vector3';
                    inputCount = 3;
                    break;
                }
                case 8: {
                    const m = [[randRange(1,5)*randSign(), randRange(1,5)*randSign()], 
                               [randRange(1,5)*randSign(), randRange(1,5)*randSign()]];
                    const v = [randRange(1,9)*randSign(), randRange(1,9)*randSign()];
                    answer = [m[0][0]*v[0] + m[0][1]*v[1], m[1][0]*v[0] + m[1][1]*v[1]];
                    text = 'matrix';
                    type = 'vector2';
                    inputCount = 2;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [m], vectors: [v], op: '√ó' };
                }
                case 9: {
                    const a = e(), b = e(), c = e();
                    const d = e(), f = e(), g = e();
                    answer = [a * d + b * f + c * g];
                    text = `[${a}, ${b}, ${c}] ¬∑ [${d}, ${f}, ${g}] =`;
                    type = 'simple';
                    break;
                }
                case 10: {
                    const v1 = [e(), e(), e()];
                    const v2 = [e(), e(), e()];
                    const v3 = [e(), e(), e()];
                    answer = [v1[0]+v2[0]+v3[0], v1[1]+v2[1]+v3[1], v1[2]+v2[2]+v3[2]];
                    text = `[${v1.join(',')}] + [${v2.join(',')}] + [${v3.join(',')}] =`;
                    type = 'vector3';
                    inputCount = 3;
                    break;
                }
                case 11: {
                    const m1 = [[randRange(1,9)*randSign(), randRange(1,9)*randSign()], 
                                [randRange(1,9)*randSign(), randRange(1,9)*randSign()]];
                    const m2 = [[randRange(1,9)*randSign(), randRange(1,9)*randSign()], 
                                [randRange(1,9)*randSign(), randRange(1,9)*randSign()]];
                    answer = [[m1[0][0]+m2[0][0], m1[0][1]+m2[0][1]], 
                              [m1[1][0]+m2[1][0], m1[1][1]+m2[1][1]]];
                    text = 'matrix';
                    type = 'matrix2x2';
                    inputCount = 4;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [m1, m2], op: '+' };
                }
                case 12: {
                    const m = [];
                    for (let i = 0; i < 3; i++) m.push([randRange(1,4)*randSign(), randRange(1,4)*randSign(), randRange(1,4)*randSign()]);
                    const v = [randRange(1,5)*randSign(), randRange(1,5)*randSign(), randRange(1,5)*randSign()];
                    answer = [
                        m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2],
                        m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2],
                        m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2]
                    ];
                    text = 'matrix';
                    type = 'vector3';
                    inputCount = 3;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [m], vectors: [v], op: '√ó' };
                }
                case 13: {
                    const a = [[randRange(1,5)*randSign(), randRange(1,5)*randSign()], 
                               [randRange(1,5)*randSign(), randRange(1,5)*randSign()]];
                    const b = [[randRange(1,5)*randSign(), randRange(1,5)*randSign()], 
                               [randRange(1,5)*randSign(), randRange(1,5)*randSign()]];
                    answer = [
                        [a[0][0]*b[0][0]+a[0][1]*b[1][0], a[0][0]*b[0][1]+a[0][1]*b[1][1]],
                        [a[1][0]*b[0][0]+a[1][1]*b[1][0], a[1][0]*b[0][1]+a[1][1]*b[1][1]]
                    ];
                    text = 'matrix';
                    type = 'matrix2x2';
                    inputCount = 4;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [a, b], op: '√ó' };
                }
                case 14: {
                    const m1 = [], m2 = [];
                    for (let i = 0; i < 3; i++) {
                        m1.push([randRange(1,5)*randSign(), randRange(1,5)*randSign(), randRange(1,5)*randSign()]);
                        m2.push([randRange(1,5)*randSign(), randRange(1,5)*randSign(), randRange(1,5)*randSign()]);
                    }
                    answer = [];
                    for (let i = 0; i < 3; i++) {
                        answer.push([m1[i][0]+m2[i][0], m1[i][1]+m2[i][1], m1[i][2]+m2[i][2]]);
                    }
                    text = 'matrix';
                    type = 'matrix3x3';
                    inputCount = 9;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [m1, m2], op: '+' };
                }
                case 15: {
                    const a = [];
                    for (let i = 0; i < 3; i++) a.push([randRange(1,4)*randSign(), randRange(1,4)*randSign()]);
                    const b = [];
                    for (let i = 0; i < 2; i++) b.push([randRange(1,4)*randSign(), randRange(1,4)*randSign(), randRange(1,4)*randSign()]);
                    answer = [];
                    for (let i = 0; i < 3; i++) {
                        answer.push([]);
                        for (let j = 0; j < 3; j++) {
                            answer[i].push(a[i][0]*b[0][j] + a[i][1]*b[1][j]);
                        }
                    }
                    text = 'matrix';
                    type = 'matrix3x3';
                    inputCount = 9;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [a, b], op: '√ó', label: '3√ó2 √ó 2√ó3' };
                }
                case 16: {
                    const a = [], b = [];
                    for (let i = 0; i < 3; i++) {
                        a.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                        b.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                    }
                    answer = [];
                    for (let i = 0; i < 3; i++) {
                        answer.push([]);
                        for (let j = 0; j < 3; j++) {
                            answer[i].push(a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j]);
                        }
                    }
                    text = 'matrix';
                    type = 'matrix3x3';
                    inputCount = 9;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [a, b], op: '√ó' };
                }
                case 17: {
                    const a = [], b = [], c = [];
                    for (let i = 0; i < 3; i++) {
                        a.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                        b.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                        c.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                    }
                    const ab = [];
                    for (let i = 0; i < 3; i++) {
                        ab.push([]);
                        for (let j = 0; j < 3; j++) {
                            ab[i].push(a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j]);
                        }
                    }
                    answer = [];
                    for (let i = 0; i < 3; i++) {
                        answer.push([ab[i][0]+c[i][0], ab[i][1]+c[i][1], ab[i][2]+c[i][2]]);
                    }
                    text = 'matrix';
                    type = 'matrix3x3';
                    inputCount = 9;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [a, b, c], ops: ['√ó', '+'] };
                }
                case 18: {
                    const a = [], b = [];
                    for (let i = 0; i < 3; i++) {
                        a.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                        b.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                    }
                    const v = [randRange(1,4)*randSign(), randRange(1,4)*randSign(), randRange(1,4)*randSign()];
                    const ab = [];
                    for (let i = 0; i < 3; i++) {
                        ab.push([]);
                        for (let j = 0; j < 3; j++) {
                            ab[i].push(a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j]);
                        }
                    }
                    answer = [
                        ab[0][0]*v[0] + ab[0][1]*v[1] + ab[0][2]*v[2],
                        ab[1][0]*v[0] + ab[1][1]*v[1] + ab[1][2]*v[2],
                        ab[2][0]*v[0] + ab[2][1]*v[1] + ab[2][2]*v[2]
                    ];
                    text = 'matrix';
                    type = 'vector3';
                    inputCount = 3;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [a, b], vectors: [v], ops: ['√ó', '√ó'] };
                }
                default:
                    return generateLinearAlgebraProblem(0);
            }
            
            return { answer, text, type, inputCount, category: cat + 32 };
        }
        
        function generateMixedProblem(cat) {
            let answer, text, type = 'simple';
            
            switch(cat) {
                case 0: {
                    const a = randRange(2, 9);
                    const x = randRange(-20, 20);
                    const b = randRange(-50, 50);
                    const c = a * x + b;
                    answer = x;
                    text = `${a}x + ${b >= 0 ? b : '(' + b + ')'} = ${c}, x = `;
                    break;
                }
                case 1: {
                    let a, b, c, d, det;
                    do {
                        a = randRange(-5, 5); b = randRange(-5, 5);
                        c = randRange(-5, 5); d = randRange(-5, 5);
                        det = a * d - b * c;
                    } while (det === 0 || Math.abs(det) > 20 || a === 0);
                    const invA = (d / det).toFixed(2);
                    const invB = (-b / det).toFixed(2);
                    const invC = (-c / det).toFixed(2);
                    const invD = (a / det).toFixed(2);
                    answer = [invA, invB, invC, invD];
                    text = 'matrix';
                    type = 'matrix2x2';
                    return { answer, text, type, inputCount: 4, category: cat + 51, matrices: [[[a, b], [c, d]]], label: 'Inverse (2 decimals):' };
                }
                case 2: {
                    const r1 = randRange(-9, 9);
                    const r2 = randRange(-9, 9);
                    const a = 1;
                    const b = -(r1 + r2);
                    const c = r1 * r2;
                    const smaller = Math.min(r1, r2);
                    const larger = Math.max(r1, r2);
                    answer = [smaller, larger];
                    text = `x¬≤ ${b >= 0 ? '+' : ''}${b}x ${c >= 0 ? '+' : ''}${c} = 0, x = `;
                    type = 'vector2';
                    return { answer, text, type, inputCount: 2, category: cat + 51 };
                }
                case 3: {
                    const n = randRange(1, 30);
                    answer = Math.pow(2, n);
                    text = `2^${n} = `;
                    break;
                }
                case 4: {
                    let a, b, c, d, det;
                    do {
                        a = randRange(1, 5); b = randRange(-3, 3);
                        c = randRange(-3, 3); d = randRange(1, 5);
                        det = a * d - b * c;
                    } while (det === 0);
                    const b1 = randRange(-10, 10);
                    const b2 = randRange(-10, 10);
                    const x1 = (d * b1 - b * b2) / det;
                    const x2 = (-c * b1 + a * b2) / det;
                    if (Number.isInteger(x1) && Number.isInteger(x2)) {
                        answer = [x1, x2];
                        text = 'matrix';
                        type = 'vector2';
                        return { answer, text, type, inputCount: 2, category: cat + 51, matrices: [[a, b], [c, d]], vectors: [[b1], [b2]], label: 'Solve Ax=b:' };
                    }
                    return generateMixedProblem(0);
                }
                case 5: {
                    const n = randRange(10, 99);
                    answer = n * n;
                    text = `${n}¬≤ = `;
                    break;
                }
                case 6: {
                    const n = randRange(2, 20);
                    answer = n * n * n;
                    text = `${n}¬≥ = `;
                    break;
                }
                case 7: {
                    const n = randRange(4, 400);
                    const root = Math.sqrt(n);
                    answer = root.toFixed(2);
                    text = `‚àö${n} = `;
                    type = 'decimal';
                    break;
                }
                case 8: {
                    const divisor = randRange(10, 99);
                    const quotient = randRange(10, 99);
                    const dividend = divisor * quotient;
                    answer = quotient;
                    text = `${dividend} √∑ ${divisor} = `;
                    break;
                }
                case 9: {
                    const a = randRange(10, 50);
                    const b = randRange(10, 50);
                    answer = a * a + b * b;
                    text = `${a}¬≤ + ${b}¬≤ = `;
                    break;
                }
                case 10: {
                    const bases = [2, 3, 4, 5, 6, 7];
                    const a = bases[Math.floor(Math.random() * bases.length)];
                    const b = randRange(2, a <= 3 ? 6 : 4);
                    answer = Math.pow(a, b);
                    text = `${a}^${b} = `;
                    break;
                }
                case 11: {
                    const n = randRange(1, 8);
                    let fact = 1;
                    for (let i = 2; i <= n; i++) fact *= i;
                    answer = fact;
                    text = `${n}! = `;
                    break;
                }
                default:
                    return generateMixedProblem(cat % 12);
            }
            return { answer: String(answer), text, type, category: cat + 51 };
        }
        
        function generateProblem() {
            let cat;
            if (Math.random() < 0.2) {
                cat = Math.max(0, complexityLevel - 1);
            } else {
                cat = Math.floor(Math.random() * Math.max(1, complexityLevel - 1));
            }
            return generateProblemForCategory(cat);
        }
        
        function renderMatrixVisual(m) {
            const rows = m.length;
            const cols = m[0].length;
            let html = '<div class="matrix-visual cols-' + cols + '">';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    html += '<div class="matrix-visual-cell">' + m[i][j] + '</div>';
                }
            }
            html += '</div>';
            return html;
        }
        
        function renderVectorVisual(v) {
            let html = '<div class="matrix-visual cols-1">';
            for (let i = 0; i < v.length; i++) {
                html += '<div class="matrix-visual-cell">' + v[i] + '</div>';
            }
            html += '</div>';
            return html;
        }
        
        function showCurrentProblem() {
            if (!currentProblem) return;
            
            const problemText = document.getElementById('problemText');
            const matrixArea = document.getElementById('matrixInputArea');
            const simpleInput = document.getElementById('answerInput');
            
            if (currentProblem.type === 'simple' || currentProblem.type === 'decimal') {
                problemText.textContent = currentProblem.text;
                matrixArea.classList.add('hidden');
                simpleInput.classList.remove('hidden');
                simpleInput.value = '';
                simpleInput.focus();
                matrixInputs = [];
            } else {
                simpleInput.classList.add('hidden');
                matrixArea.classList.remove('hidden');
                matrixArea.innerHTML = '';
                matrixInputs = [];
                currentInputIndex = 0;
                
                if (currentProblem.matrices || currentProblem.vectors) {
                    let displayHtml = '<div class="matrix-display">';
                    const matrices = currentProblem.matrices || [];
                    const vectors = currentProblem.vectors || [];
                    const ops = currentProblem.ops || (currentProblem.op ? [currentProblem.op] : []);
                    
                    let opIdx = 0;
                    for (let i = 0; i < matrices.length; i++) {
                        const m = matrices[i];
                        if (Array.isArray(m[0])) {
                            displayHtml += renderMatrixVisual(m);
                        } else {
                            displayHtml += renderVectorVisual(m);
                        }
                        if (opIdx < ops.length && (i < matrices.length - 1 || vectors.length > 0)) {
                            displayHtml += '<span class="matrix-op">' + ops[opIdx] + '</span>';
                            opIdx++;
                        }
                    }
                    for (let i = 0; i < vectors.length; i++) {
                        const v = vectors[i];
                        if (Array.isArray(v[0])) {
                            displayHtml += renderVectorVisual(v.map(row => row[0]));
                        } else {
                            displayHtml += renderVectorVisual(v);
                        }
                        if (opIdx < ops.length && i < vectors.length - 1) {
                            displayHtml += '<span class="matrix-op">' + ops[opIdx] + '</span>';
                            opIdx++;
                        }
                    }
                    displayHtml += '<span class="matrix-op">=</span>';
                    displayHtml += '</div>';
                    
                    problemText.innerHTML = currentProblem.label ? currentProblem.label : '';
                    matrixArea.innerHTML = displayHtml;
                } else {
                    problemText.textContent = currentProblem.text;
                }
                
                let rows, cols;
                if (currentProblem.type === 'vector2') { rows = 2; cols = 1; }
                else if (currentProblem.type === 'vector3') { rows = 3; cols = 1; }
                else if (currentProblem.type === 'matrix2x2') { rows = 2; cols = 2; }
                else if (currentProblem.type === 'matrix3x3') { rows = 3; cols = 3; }
                
                const container = document.createElement('div');
                container.className = 'matrix-grid matrix-' + rows + 'x' + cols;
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.className = 'matrix-cell';
                        input.dataset.row = i;
                        input.dataset.col = j;
                        input.autocomplete = 'off';
                        
                        input.addEventListener('keydown', handleMatrixKeydown);
                        input.addEventListener('input', checkMatrixAnswer);
                        
                        matrixInputs.push(input);
                        container.appendChild(input);
                    }
                }
                
                matrixArea.appendChild(container);
                matrixInputs[0].focus();
            }
        }
        
        function handleMatrixKeydown(e) {
            if (e.key === 'Tab') {
                e.preventDefault();
                const idx = matrixInputs.indexOf(e.target);
                const nextIdx = (idx + 1) % matrixInputs.length;
                matrixInputs[nextIdx].focus();
                matrixInputs[nextIdx].select();
            } else if (e.key === 'Enter') {
                checkMatrixAnswer();
            }
        }
        
        function checkMatrixAnswer() {
            if (!currentProblem || currentProblem.type === 'simple' || currentProblem.type === 'decimal') return;
            
            const values = matrixInputs.map(inp => inp.value.trim());
            if (values.some(v => v === '')) return;
            
            let correct = true;
            const answer = currentProblem.answer;
            
            const isDecimalMatrix = Array.isArray(answer) && typeof answer[0] === 'string';
            
            if (currentProblem.type === 'vector2' || currentProblem.type === 'vector3') {
                for (let i = 0; i < answer.length; i++) {
                    const userVal = parseFloat(values[i]);
                    const correctVal = parseFloat(answer[i]);
                    if (isNaN(userVal) || Math.abs(userVal - correctVal) > 0.05) correct = false;
                }
            } else if (currentProblem.type === 'matrix2x2') {
                if (isDecimalMatrix) {
                    for (let i = 0; i < 4; i++) {
                        const userVal = parseFloat(values[i]);
                        const correctVal = parseFloat(answer[i]);
                        if (isNaN(userVal) || Math.abs(userVal - correctVal) > 0.05) correct = false;
                    }
                } else {
                    if (parseInt(values[0]) !== answer[0][0]) correct = false;
                    if (parseInt(values[1]) !== answer[0][1]) correct = false;
                    if (parseInt(values[2]) !== answer[1][0]) correct = false;
                    if (parseInt(values[3]) !== answer[1][1]) correct = false;
                }
            } else if (currentProblem.type === 'matrix3x3') {
                let idx = 0;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (parseInt(values[idx]) !== answer[i][j]) correct = false;
                        idx++;
                    }
                }
            }
            
            if (correct) solveProblem();
        }
        
        function updateDisplay() {
            document.getElementById('computations').textContent = formatNumber(computations);
            document.getElementById('compRate').textContent = '+' + formatNumber(getComputationsPerSecond()) + '/sec';
            document.getElementById('totalSolved').textContent = formatNumber(totalSolved);
            const flops = getFLOPS();
            const flopsMult = 0.05 + (flops / 15);
            document.getElementById('flopsDisplay').textContent = flops.toFixed(0) + ' (√ó' + flopsMult.toFixed(2) + ')';
            document.getElementById('bonusSolved').textContent = bonusSolved;
            
            document.getElementById('eraName').textContent = getEraName() + ' ERA';
            const bitEl = document.getElementById('bitDisplay');
            bitEl.textContent = formatBitComplexity(complexityLevel);
            
            bitEl.classList.remove('glowing', 'glowing-intense');
            if (complexityLevel >= 40) {
                bitEl.classList.add('glowing-intense');
            } else if (complexityLevel >= 20) {
                bitEl.classList.add('glowing');
            }
            
            const currentThreshold = getComplexityThreshold(complexityLevel);
            const nextThreshold = getComplexityThreshold(complexityLevel + 1);
            const progress = complexityLevel >= 60 ? 100 : ((totalSolved - currentThreshold) / (nextThreshold - currentThreshold)) * 100;
            document.getElementById('stageFill').style.width = Math.min(100, Math.max(0, progress)) + '%';
            document.getElementById('stageNext').textContent = complexityLevel >= 60 ? 'MAX' : 'next: ' + formatNumber(nextThreshold);
            
            document.getElementById('streakFill').style.width = Math.min(100, (stats.streak % 50) * 2) + '%';
            
            if (bonusProblemData) {
                const remaining = Math.max(0, Math.ceil((bonusEndTime - Date.now()) / 1000));
                document.getElementById('bonusTimer').textContent = remaining + 's';
            }
            
            updateActiveEffects();
            updateShopDisplay();
        }
        
        function updateActiveEffects() {
            const el = document.getElementById('activeEffects');
            let html = '';
            if (facilityBoostActive) {
                const rem = Math.ceil((facilityBoostEnd - Date.now()) / 1000);
                html += `<div class="effect-badge facility">‚ö° 5√ó (${rem}s)</div>`;
            }
            if (solveBoostActive) {
                const rem = Math.ceil((solveBoostEnd - Date.now()) / 1000);
                html += `<div class="effect-badge solve">üß† 10√ó (${rem}s)</div>`;
            }
            el.innerHTML = html;
        }
        
        function getOrderedEraFacilities(era) {
            const order = {
                1: ['fingerCounting', 'tallySticks', 'countingBeads', 'stoneTablets', 'pencilPaper', 'abacus', 'trufflePig'],
                2: ['slideRule', 'vacuumTube', 'steamMachine', 'monkeyTypist', 'analyticalEngine', 'differentialAnalyzer', 'probabilityOracle'],
                3: ['pocketCalculator', 'personalComputer', 'solarFarm', 'tpu', 'hypercomputer', 'computeCluster', 'timeloops', 'quantumCore'],
                4: ['superintelligence', 'dysonSwarm', 'thamiel', 'matrioshkaBrain', 'timeCrystal', 'dodecahedron', 'multiversalSync', 'omegaPoint']
            };
            return order[era] || [];
        }
        
        function isFacilityUnlocked(key) {
            const cfg = CONFIG.facilities[key];
            if (cfg.era > currentEra) return false;
            
            const eraFacilities = getOrderedEraFacilities(cfg.era);
            const index = eraFacilities.indexOf(key);
            
            if (index === 0) return true;
            
            const prevKey = eraFacilities[index - 1];
            return facilities[prevKey].owned >= 1;
        }
        
        function checkGeneralUpgradeVisible(cfg) {
            if (!cfg.reqStat) return true;
            
            switch(cfg.reqStat) {
                case 'opm100': return getFLOPS() >= 50;
                case 'prob500': return stats.probSolved >= 100;
                case 'matrix500': return stats.matrixSolved >= 100;
                case 'wrong100': return stats.wrongAnswers >= 25;
                case 'arith1000': return stats.arithSolved >= 250;
                case 'play1hr': return stats.playTime >= 1800;
                case 'play10hr': return stats.playTime >= 18000;
                case 'solved100k': return stats.totalSolved >= 25000;
                case 'solved1m': return stats.totalSolved >= 250000;
                case 'era1complete': return currentEra >= 1;
                case 'era2complete': return currentEra >= 2;
                case 'era3complete': return currentEra >= 3;
                case 'era4complete': return currentEra >= 4;
                case 'allFacilities': return currentEra >= 4;
                case 'oneOfEach': return Object.values(facilities).filter(f => f.owned >= 1).length >= 3;
                case 'solved50': return totalSolved >= 25;
                case 'solved100': return totalSolved >= 50;
                case 'solved250': return totalSolved >= 125;
                case 'solved500': return totalSolved >= 250;
                case 'solved750': return totalSolved >= 375;
                case 'solved1000': return totalSolved >= 500;
                case 'solved2000': return totalSolved >= 1000;
                case 'solved3000': return totalSolved >= 1500;
                case 'era4': return currentEra >= 4;
                default: return true;
            }
        }
        
        function checkGeneralUpgradeUnlocked(cfg) {
            if (!cfg.reqStat) return true;
            
            switch(cfg.reqStat) {
                case 'opm100': return getFLOPS() >= 100;
                case 'prob500': return stats.probSolved >= 500;
                case 'matrix500': return stats.matrixSolved >= 500;
                case 'wrong100': return stats.wrongAnswers >= 100;
                case 'arith1000': return stats.arithSolved >= 1000;
                case 'play1hr': return stats.playTime >= 3600;
                case 'play10hr': return stats.playTime >= 36000;
                case 'solved100k': return stats.totalSolved >= 100000;
                case 'solved1m': return stats.totalSolved >= 1000000;
                case 'era1complete': {
                    const era1Facs = getOrderedEraFacilities(1);
                    return era1Facs.every(k => facilities[k].owned >= 1);
                }
                case 'era2complete': {
                    const era2Facs = getOrderedEraFacilities(2);
                    return era2Facs.every(k => facilities[k].owned >= 1);
                }
                case 'era3complete': {
                    const era3Facs = getOrderedEraFacilities(3);
                    return era3Facs.every(k => facilities[k].owned >= 1);
                }
                case 'era4complete': {
                    const era4Facs = getOrderedEraFacilities(4);
                    return era4Facs.every(k => facilities[k].owned >= 1);
                }
                case 'allFacilities': {
                    return Object.values(facilities).every(f => f.owned >= 1);
                }
                case 'oneOfEach': {
                    for (let era = 1; era <= currentEra; era++) {
                        const facs = getOrderedEraFacilities(era);
                        if (!facs.every(k => facilities[k].owned >= 1)) return false;
                    }
                    return true;
                }
                case 'solved50': return totalSolved >= 50;
                case 'solved100': return totalSolved >= 100;
                case 'solved250': return totalSolved >= 250;
                case 'solved500': return totalSolved >= 500;
                case 'solved750': return totalSolved >= 750;
                case 'solved1000': return totalSolved >= 1000;
                case 'solved2000': return totalSolved >= 2000;
                case 'solved3000': return totalSolved >= 3000;
                case 'era4': return currentEra >= 4;
                default: return true;
            }
        }
        
        function updateShopDisplay() {
            Object.keys(CONFIG.facilities).forEach(k => {
                const cfg = CONFIG.facilities[k];
                const btn = document.getElementById('buy_' + k);
                if (!btn) return;
                
                const price = getPrice(cfg.basePrice, cfg.priceMultiplier, facilities[k].owned);
                const eraUnlocked = cfg.era <= currentEra;
                const facilityUnlocked = isFacilityUnlocked(k);
                const alreadyOwned = facilities[k].owned >= 1;
                
                if (!eraUnlocked || !facilityUnlocked) {
                    btn.classList.add('hidden');
                    return;
                }
                
                btn.classList.remove('hidden', 'locked', 'mystery');
                document.getElementById('name_' + k).textContent = cfg.name;
                document.getElementById('desc_' + k).textContent = cfg.desc;
                document.getElementById('cost_' + k).textContent = formatNumber(price);
                document.getElementById('owned_' + k).textContent = facilities[k].owned;
                btn.disabled = computations < price;
            });
            
            Object.keys(CONFIG.upgrades).forEach(k => {
                const cfg = CONFIG.upgrades[k];
                const btn = document.getElementById('buy_' + k);
                if (!btn) return;
                
                const owned = upgrades[k].owned;
                
                if (owned) {
                    btn.classList.add('bought', 'hidden');
                    return;
                }
                
                let visible = false;
                let canBuy = false;
                
                if (cfg.type === 'tiered') {
                    const facOwned = facilities[cfg.facility]?.owned || 0;
                    visible = facOwned >= cfg.reqOwned;
                    canBuy = facOwned >= cfg.reqOwned;
                } else if (cfg.type === 'synergy') {
                    const fac1Owned = facilities[cfg.facility]?.owned || 0;
                    const fac2Owned = facilities[cfg.synergyWith]?.owned || 0;
                    visible = fac1Owned >= cfg.reqOwned && fac2Owned >= cfg.reqOwned;
                    canBuy = visible;
                } else if (cfg.type === 'general') {
                    visible = checkGeneralUpgradeUnlocked(cfg);
                    canBuy = visible;
                }
                
                if (!visible) {
                    btn.classList.add('hidden');
                    return;
                }
                
                btn.classList.remove('hidden', 'bought', 'locked');
                const costEl = document.getElementById('ucost_' + k);
                if (costEl) costEl.textContent = formatNumber(cfg.basePrice);
                btn.disabled = computations < cfg.basePrice;
            });
            
            Object.keys(CONFIG.pets).forEach(k => {
                const cfg = CONFIG.pets[k];
                const btn = document.getElementById('buy_pet_' + k);
                if (!btn) return;
                
                if (pets[k]?.owned) {
                    btn.classList.add('bought', 'hidden');
                    return;
                }
                
                const eraUnlocked = cfg.era <= currentEra;
                const timeUnlocked = (stats.eraTime[cfg.era] || 0) >= cfg.unlockTime;
                
                if (!eraUnlocked) {
                    btn.classList.add('hidden');
                    return;
                }
                
                btn.classList.remove('hidden', 'bought');
                
                if (!timeUnlocked) {
                    btn.classList.add('locked');
                    const remaining = Math.ceil((cfg.unlockTime - (stats.eraTime[cfg.era] || 0)) / 60);
                    const costEl = document.getElementById('pcost_' + k);
                    if (costEl) costEl.textContent = remaining + 'm left';
                    btn.disabled = true;
                } else {
                    btn.classList.remove('locked');
                    const costEl = document.getElementById('pcost_' + k);
                if (costEl) costEl.textContent = formatNumber(cfg.basePrice);
                    btn.disabled = computations < cfg.basePrice;
                }
            });
        }
        
        function buyFacility(key) {
            const cfg = CONFIG.facilities[key];
            const price = getPrice(cfg.basePrice, cfg.priceMultiplier, facilities[key].owned);
            if (computations >= price && cfg.era <= currentEra && isFacilityUnlocked(key)) {
                computations -= price;
                facilities[key].owned++;
                playPurchase();
                flashPurchase();
                checkEraUnlock();
                saveGame();
            }
        }
        
        function buyUpgrade(key) {
            const cfg = CONFIG.upgrades[key];
            if (upgrades[key].owned || computations < cfg.basePrice) return;
            
            let canBuy = false;
            if (cfg.type === 'tiered') {
                canBuy = (facilities[cfg.facility]?.owned || 0) >= cfg.reqOwned;
            } else if (cfg.type === 'synergy') {
                const fac1 = facilities[cfg.facility]?.owned || 0;
                const fac2 = facilities[cfg.synergyWith]?.owned || 0;
                canBuy = fac1 >= cfg.reqOwned && fac2 >= cfg.reqOwned;
            } else if (cfg.type === 'general') {
                canBuy = true;
            }
            
            if (canBuy) {
                computations -= cfg.basePrice;
                upgrades[key].owned = true;
                playPurchase();
                flashPurchase();
                saveGame();
            }
        }
        
        function buyPet(key) {
            const cfg = CONFIG.pets[key];
            if (pets[key].owned || computations < cfg.basePrice) return;
            if (cfg.era > currentEra) return;
            if ((stats.eraTime[cfg.era] || 0) < cfg.unlockTime) return;
            
            computations -= cfg.basePrice;
            pets[key].owned = true;
            playPurchase();
            flashPurchase();
            renderPets();
            saveGame();
        }
        
        function renderPets() {
            const container = document.getElementById('petsContainer');
            container.innerHTML = '';
            
            const petImages = {
                nikodemus: 'assets/pets/nikodemus.png',
                bjartur: 'assets/pets/bjartur.png',
                yuki: 'assets/pets/yuki.png',
                aineko: 'assets/pets/aineko.png'
            };
            
            let petIndex = 0;
            Object.entries(CONFIG.pets).forEach(([k, v]) => {
                if (!pets[k]?.owned) return;
                
                const pet = document.createElement('div');
                pet.className = 'pet pet-' + k + ' era-' + v.era;
                pet.style.left = (20 + petIndex * 100) + 'px';
                pet.dataset.name = v.name;
                pet.innerHTML = `
                    <img class="pet-image" src="${petImages[k]}" alt="${v.name}">
                    <div class="pet-name">${v.name}</div>
                    <div class="pet-speech hidden">*meow*</div>
                `;
                pet.addEventListener('click', () => petMeow(pet));
                container.appendChild(pet);
                petIndex++;
            });
        }
        
        function petMeow(petEl) {
            petEl.classList.add('pet-clicked');
            const speech = petEl.querySelector('.pet-speech');
            speech.classList.remove('hidden');
            speech.classList.add('show');
            playBeep(800, 0.05);
            setTimeout(() => playBeep(600, 0.05), 80);
            setTimeout(() => {
                petEl.classList.remove('pet-clicked');
            }, 400);
            setTimeout(() => {
                speech.classList.remove('show');
                speech.classList.add('hidden');
            }, 1500);
        }
        
        function flashPurchase() {
            const box = document.getElementById('gameBox');
            box.classList.add('purchase-flash');
            setTimeout(() => box.classList.remove('purchase-flash'), 200);
        }
        
        function solveProblem() {
            if (!currentProblem) return;
            totalSolved++;
            stats.totalSolved++;
            stats.streak++;
            const flopCount = FLOP_COUNTS[currentProblem.category] ?? 1;
            solveTimestamps.push({ time: Date.now(), flops: flopCount });
            
            if (currentProblem.category < 16) stats.arithSolved++;
            else if (currentProblem.category < 32) stats.probSolved++;
            else stats.matrixSolved++;
            
            computations += getSolveValue();
            playCorrect();
            
            const simpleInput = document.getElementById('answerInput');
            simpleInput.value = '';
            simpleInput.classList.add('correct');
            setTimeout(() => simpleInput.classList.remove('correct'), 150);
            
            checkComplexityUp();
            checkEraUnlock();
            
            if (queue.length > 0) { 
                currentProblem = queue.shift(); 
                showCurrentProblem(); 
                updateQueueDisplay(); 
            } else { 
                currentProblem = null; 
                document.getElementById('problemText').textContent = '...'; 
            }
            fillQueue();
            saveGame();
        }
        
        function updateQueueDisplay() {
            const el = document.getElementById('queueList');
            el.innerHTML = '';
            queue.forEach((p, i) => {
                const div = document.createElement('div');
                div.className = 'queue-item';
                div.textContent = p.text;
                div.style.opacity = 1 - (i * 0.25);
                el.appendChild(div);
            });
        }
        
        function spawnProblem() {
            const problem = generateProblem();
            if (!currentProblem) { currentProblem = problem; showCurrentProblem(); }
            else if (queue.length < CONFIG.queue.maxSize) { queue.push(problem); updateQueueDisplay(); }
        }
        
        function fillQueue() {
            while (queue.length < CONFIG.queue.maxSize) spawnProblem();
            if (!currentProblem) spawnProblem();
        }
        
        document.getElementById('answerInput').addEventListener('input', function() {
            if (!currentProblem) return;
            if (currentProblem.type === 'simple') {
                if (parseInt(this.value, 10) === parseInt(currentProblem.answer)) solveProblem();
            } else if (currentProblem.type === 'decimal') {
                const userVal = parseFloat(this.value);
                const correctVal = parseFloat(currentProblem.answer);
                if (!isNaN(userVal) && Math.abs(userVal - correctVal) < 0.005) solveProblem();
            }
        });
        
        document.getElementById('bonusInput').addEventListener('input', function() {
            if (!bonusProblemData) return;
            if (parseInt(this.value, 10) === parseInt(bonusProblemData.answer)) {
                bonusSolved++;
                playBonus();
                applyBonusEffect(bonusProblemData.effect);
                hideBonusProblem();
            }
        });
        
        function saveGame() {
            lastSaveTime = Date.now();
            const save = {
                computations, totalSolved, bonusSolved, currentEra, complexityLevel, stats,
                facilities: Object.fromEntries(Object.entries(facilities).map(([k,v]) => [k, v.owned])),
                upgrades: Object.fromEntries(Object.entries(upgrades).map(([k,v]) => [k, v.owned])),
                pets: Object.fromEntries(Object.entries(pets).map(([k,v]) => [k, v.owned])),
                facilityBoostEnd, solveBoostEnd, lastSaveTime
            };
            localStorage.setItem(CONFIG.saveKey, JSON.stringify(save));
        }
        
        function loadGame() {
            const saved = localStorage.getItem(CONFIG.saveKey);
            if (saved) {
                const s = JSON.parse(saved);
                computations = s.computations || 0;
                totalSolved = s.totalSolved || 0;
                bonusSolved = s.bonusSolved || 0;
                currentEra = s.currentEra || 1;
                complexityLevel = s.complexityLevel || 1;
                if (s.stats) stats = { ...stats, ...s.stats };
                
                Object.keys(facilities).forEach(k => { facilities[k].owned = s.facilities?.[k] || 0; });
                Object.keys(upgrades).forEach(k => { upgrades[k].owned = !!s.upgrades?.[k]; });
                Object.keys(pets).forEach(k => { pets[k].owned = !!s.pets?.[k]; });
                if (s.stats?.eraTime) stats.eraTime = { ...stats.eraTime, ...s.stats.eraTime };
                
                if (s.facilityBoostEnd > Date.now()) { facilityBoostActive = true; facilityBoostEnd = s.facilityBoostEnd; }
                if (s.solveBoostEnd > Date.now()) { solveBoostActive = true; solveBoostEnd = s.solveBoostEnd; }
                
                if (s.lastSaveTime) {
                    const offlineMs = Math.min(Date.now() - s.lastSaveTime, CONFIG.offline.maxOfflineMinutes * 60000);
                    const rate = getComputationsPerSecond();
                    const earnings = (offlineMs / 1000) * rate * CONFIG.offline.offlineEfficiency;
                    if (earnings > 1) computations += earnings;
                    stats.offlineTime += offlineMs / 1000;
                }
                
                updateVisualFlair();
                renderPets();
            }
        }
        
        document.addEventListener('click', () => { if (audioCtx.state === 'suspended') audioCtx.resume(); }, { once: true });
        
        loadConfig();
    </script>
</body>
</html>
