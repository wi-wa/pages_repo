<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>And it goes brr..</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.cdnfonts.com/css/fixedsys-excelsior-301" rel="stylesheet">
</head>
<body>
    <div class="top-bar">
        <a href="../index.html" class="back-link">‚Üê back</a>
        <span class="game-title">And it goes brr..</span>
        <div class="settings-btn" id="settingsBtn" title="Settings">‚öô</div>
    </div>
    
    <div class="settings-panel hidden" id="settingsPanel">
        <div class="settings-header">Settings</div>
        <button class="settings-option reset-btn" id="resetBtn">üóë Reset Game</button>
        <button class="settings-close" id="settingsClose">‚úï</button>
    </div>
    
    <div class="confirm-modal hidden" id="confirmModal">
        <div class="confirm-box">
            <div class="confirm-text">Are you sure you want to reset?<br>All progress will be lost!</div>
            <div class="confirm-buttons">
                <button class="confirm-yes" id="confirmYes">Yes, Reset</button>
                <button class="confirm-no" id="confirmNo">Cancel</button>
            </div>
        </div>
    </div>
    
    <div class="stage-flash hidden" id="stageFlash"></div>
    <div class="opm-flash hidden" id="opmFlash"></div>
    
    <div class="bonus-problem-popup hidden" id="bonusProblem">
        <div class="bonus-header">‚ö° BONUS ‚ö°</div>
        <div class="bonus-timer" id="bonusTimer">20s</div>
        <div class="bonus-reward" id="bonusReward">???</div>
        <div class="bonus-input-row">
            <span class="bonus-text" id="bonusProblemText">99 √ó 99 =</span>
            <input type="text" class="bonus-input" id="bonusInput" autocomplete="off">
        </div>
    </div>
    
    <div class="active-effects" id="activeEffects"></div>
    
    <div class="main-content">
        <div class="left-panel">
            <div class="stage-display">
                <div class="stage-label" id="stageLabel">MENTAL STAGE</div>
                <div class="stage-number" id="stageNumber" title="Click to advance stage (debug)">1</div>
                <div class="stage-progress">
                    <div class="stage-fill" id="stageFill"></div>
                </div>
                <div class="stage-next" id="stageNext">next: 100</div>
            </div>
            
            <div class="stats-section">
                <div class="stat-row">
                    <span class="stat-name">solved</span>
                    <span class="stat-val" id="totalSolved">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-name">opm</span>
                    <span class="stat-val" id="opmDisplay">0.0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-name">bonus</span>
                    <span class="stat-val" id="bonusSolved">0</span>
                </div>
            </div>
            
            <div class="complexity-section">
                <div class="symbol-flicker" id="symbolFlicker">01</div>
                <div class="bit-display" id="bitDisplay">1-bit</div>
            </div>
            
            <div class="next-bonus">
                <span class="bonus-label">bonus in</span>
                <span class="bonus-countdown" id="bonusCountdown">~5:00</span>
            </div>
        </div>
        
        <div class="game-box" id="gameBox">
            <div class="computations-display">
                <span class="comp-value" id="computations" title="Click to double (debug)">0</span>
                <span class="comp-label">computations</span>
                <span class="comp-rate" id="compRate">+0.0/sec</span>
            </div>
            
            <div class="problem-area">
                <div class="problem-stack">
                    <div class="input-row" id="inputRow">
                        <span class="problem-text" id="problemText">1 + 1 =</span>
                        <input type="text" class="answer-input" id="answerInput" autocomplete="off">
                    </div>
                    <div class="matrix-input-area hidden" id="matrixInputArea"></div>
                    <div class="queue-list" id="queueList"></div>
                </div>
            </div>
            
            <div class="streak-bar">
                <div class="streak-fill" id="streakFill"></div>
            </div>
        </div>
    </div>
    
    <div class="shop-panel">
        <div class="shop-tabs">
            <button class="tab-btn active" data-tab="facilities">Facilities</button>
            <button class="tab-btn" data-tab="upgrades">Upgrades</button>
        </div>
        
        <div class="tab-content" id="facilitiesTab"></div>
        <div class="tab-content hidden" id="upgradesTab"></div>
    </div>

    <script>
        let CONFIG = {};
        
        async function loadConfig() {
            const response = await fetch('config.json');
            CONFIG = await response.json();
            initGame();
        }
        
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playBeep(freq, dur) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = freq;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            osc.start();
            osc.stop(audioCtx.currentTime + dur);
        }
        
        function playCorrect() { playBeep(CONFIG.audio.beepFrequency, CONFIG.audio.beepDuration); }
        function playBonus() { 
            playBeep(CONFIG.audio.bonusBeepFrequency, CONFIG.audio.bonusBeepDuration);
            setTimeout(() => playBeep(CONFIG.audio.bonusBeepFrequency * 1.5, CONFIG.audio.bonusBeepDuration), 100);
        }
        function playStageUp() {
            playBeep(CONFIG.audio.stageUpFrequency, CONFIG.audio.stageUpDuration);
            setTimeout(() => playBeep(CONFIG.audio.stageUpFrequency * 1.25, CONFIG.audio.stageUpDuration), 150);
            setTimeout(() => playBeep(CONFIG.audio.stageUpFrequency * 1.5, CONFIG.audio.stageUpDuration * 1.5), 300);
        }
        function playPurchase() { playBeep(380, 0.08); }
        
        let queue = [], currentProblem = null;
        let computations = 0, totalSolved = 0, bonusSolved = 0;
        let currentStage = 1, unlockedCategories = 1;
        let lastSaveTime = Date.now();
        let facilities = {}, upgrades = {};
        
        let facilityBoostActive = false, facilityBoostEnd = 0;
        let solveBoostActive = false, solveBoostEnd = 0;
        let nextBonusTime = 0, bonusProblemData = null, bonusEndTime = 0;
        
        let solveTimestamps = [];
        let matrixInputs = [];
        let currentInputIndex = 0;
        let lastOpmTier = 0;
        
        const symbols = '01‚àë‚àè‚à´‚àöœÄŒî‚àÇŒª‚àû‚âà‚â†¬±√ó√∑Œ±Œ≤Œ≥Œ∏Œ©‚àá';
        
        function getEra() {
            if (currentStage <= 16) return 1;
            if (currentStage <= 32) return 2;
            if (currentStage <= 51) return 3;
            return 4;
        }
        
        function getEraName() {
            const era = getEra();
            return ['MENTAL', 'ANALOG', 'DIGITAL', 'ASI'][era - 1];
        }
        
        function getStageThreshold(stage) {
            if (stage <= 1) return 0;
            let total = 0;
            let increment = CONFIG.stageUnlock.baseProblems;
            for (let i = 2; i <= stage; i++) {
                total += Math.floor(increment);
                increment *= CONFIG.stageUnlock.growthRate;
            }
            return total;
        }
        
        function initGame() {
            Object.keys(CONFIG.facilities).forEach(k => { facilities[k] = { owned: 0 }; });
            Object.keys(CONFIG.upgrades).forEach(k => { upgrades[k] = { level: 0 }; });
            
            buildShopUI();
            loadGame();
            scheduleNextBonus();
            fillQueue();
            updateDisplay();
            document.getElementById('answerInput').focus();
            
            setInterval(gameTick, CONFIG.tickIntervalMs);
            setInterval(saveGame, CONFIG.saveIntervalMs);
            setInterval(flickerSymbols, 50);
            
            setupTabs();
            setupDebugClicks();
        }
        
        function setupDebugClicks() {
            document.getElementById('stageNumber').addEventListener('click', () => {
                currentStage++;
                unlockedCategories = currentStage;
                playStageUp();
                showStageFlash();
                updateVisualFlair();
                updateDisplay();
                saveGame();
            });
            
            document.getElementById('computations').addEventListener('click', () => {
                computations = Math.max(computations * 2, 100);
                updateDisplay();
            });
            
            document.getElementById('settingsBtn').addEventListener('click', () => {
                document.getElementById('settingsPanel').classList.toggle('hidden');
            });
            
            document.getElementById('settingsClose').addEventListener('click', () => {
                document.getElementById('settingsPanel').classList.add('hidden');
            });
            
            document.getElementById('resetBtn').addEventListener('click', () => {
                document.getElementById('settingsPanel').classList.add('hidden');
                document.getElementById('confirmModal').classList.remove('hidden');
            });
            
            document.getElementById('confirmNo').addEventListener('click', () => {
                document.getElementById('confirmModal').classList.add('hidden');
            });
            
            document.getElementById('confirmYes').addEventListener('click', () => {
                resetGame();
                document.getElementById('confirmModal').classList.add('hidden');
            });
        }
        
        function resetGame() {
            localStorage.removeItem('computation_factory_v8');
            computations = 0;
            totalSolved = 0;
            bonusSolved = 0;
            currentStage = 1;
            unlockedCategories = 1;
            Object.keys(facilities).forEach(k => { facilities[k].owned = 0; });
            Object.keys(upgrades).forEach(k => { upgrades[k].level = 0; });
            facilityBoostActive = false;
            solveBoostActive = false;
            queue = [];
            currentProblem = null;
            solveTimestamps = [];
            lastOpmTier = 0;
            scheduleNextBonus();
            fillQueue();
            updateVisualFlair();
            updateDisplay();
            document.getElementById('answerInput').focus();
        }
        
        function buildShopUI() {
            const facTab = document.getElementById('facilitiesTab');
            const upgTab = document.getElementById('upgradesTab');
            facTab.innerHTML = '';
            upgTab.innerHTML = '';
            
            Object.entries(CONFIG.facilities).forEach(([k, v]) => {
                const btn = document.createElement('button');
                btn.className = 'shop-item facility era-' + v.era;
                btn.id = 'buy_' + k;
                btn.dataset.unlockStage = v.unlockStage;
                btn.disabled = true;
                btn.innerHTML = `
                    <div class="item-info">
                        <span class="item-name" id="name_${k}">${v.name}</span>
                        <span class="item-desc" id="desc_${k}">${v.desc}</span>
                        <span class="item-owned">√ó<span id="owned_${k}">0</span></span>
                    </div>
                    <span class="item-cost" id="cost_${k}">${formatNumber(v.basePrice)}</span>
                `;
                btn.addEventListener('click', () => buyFacility(k));
                facTab.appendChild(btn);
            });
            
            Object.entries(CONFIG.upgrades).forEach(([k, v]) => {
                const btn = document.createElement('button');
                btn.className = 'shop-item upgrade';
                btn.id = 'buy_' + k;
                btn.dataset.unlockStage = v.unlockStage;
                btn.disabled = true;
                btn.innerHTML = `
                    <div class="item-info">
                        <span class="item-name" id="uname_${k}">${v.name}</span>
                        <span class="item-desc" id="udesc_${k}">${v.desc}</span>
                        <span class="item-owned">Lv.<span id="level_${k}">0</span>/${v.maxLevel}</span>
                    </div>
                    <span class="item-cost" id="cost_${k}">${formatNumber(v.basePrice)}</span>
                `;
                btn.addEventListener('click', () => buyUpgrade(k));
                upgTab.appendChild(btn);
            });
        }
        
        function setupTabs() {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById('facilitiesTab').classList.toggle('hidden', btn.dataset.tab !== 'facilities');
                    document.getElementById('upgradesTab').classList.toggle('hidden', btn.dataset.tab !== 'upgrades');
                });
            });
        }
        
        function gameTick() {
            computations += getComputationsPerSecond() / 10;
            
            if (facilityBoostActive && Date.now() > facilityBoostEnd) {
                facilityBoostActive = false;
            }
            if (solveBoostActive && Date.now() > solveBoostEnd) {
                solveBoostActive = false;
            }
            
            if (bonusProblemData && Date.now() > bonusEndTime) {
                hideBonusProblem();
            }
            
            if (!bonusProblemData && Date.now() > nextBonusTime) {
                showBonusProblem();
            }
            
            checkOpmFlair();
            updateDisplay();
        }
        
        function checkOpmFlair() {
            const opm = getOPM();
            const tiers = [10, 30, 60, 100, 150];
            let currentTier = 0;
            for (let i = 0; i < tiers.length; i++) {
                if (opm >= tiers[i]) currentTier = i + 1;
            }
            
            if (currentTier > lastOpmTier && currentTier > 0) {
                showOpmFlash(currentTier);
                document.body.classList.add('opm-boost-' + currentTier);
            } else if (currentTier < lastOpmTier) {
                for (let i = 1; i <= 5; i++) {
                    document.body.classList.remove('opm-boost-' + i);
                }
                if (currentTier > 0) document.body.classList.add('opm-boost-' + currentTier);
            }
            lastOpmTier = currentTier;
        }
        
        function showOpmFlash(tier) {
            const flash = document.getElementById('opmFlash');
            const msgs = ['', 'üî• 10 OPM!', '‚ö° 30 OPM!', 'üí´ 60 OPM!', 'üåü 100 OPM!', 'üöÄ 150 OPM!'];
            flash.textContent = msgs[tier];
            flash.classList.remove('hidden');
            flash.classList.add('show');
            setTimeout(() => {
                flash.classList.remove('show');
                setTimeout(() => flash.classList.add('hidden'), 500);
            }, 1000);
        }
        
        function getUpgradeMultiplier() {
            let mult = 1;
            Object.entries(upgrades).forEach(([k, v]) => {
                mult += v.level * CONFIG.upgrades[k].effect;
            });
            return mult;
        }
        
        function getComputationsPerSecond() {
            let base = 0;
            Object.entries(facilities).forEach(([k, v]) => {
                if (CONFIG.facilities[k].unlockStage <= currentStage) {
                    base += v.owned * CONFIG.facilities[k].baseRate;
                }
            });
            let mult = getUpgradeMultiplier();
            if (facilityBoostActive) mult *= CONFIG.bonusProblem.effects.facilityBoost.multiplier;
            return base * mult;
        }
        
        function getSolveValue() {
            let base = getUpgradeMultiplier();
            if (solveBoostActive) base *= CONFIG.bonusProblem.effects.solveBoost.multiplier;
            return base;
        }
        
        function getOPM() {
            const now = Date.now();
            const oneMinAgo = now - 60000;
            solveTimestamps = solveTimestamps.filter(t => t > oneMinAgo);
            return solveTimestamps.length;
        }
        
        function scheduleNextBonus() {
            const variance = (Math.random() - 0.5) * CONFIG.bonusProblem.averageIntervalMs * 0.5;
            nextBonusTime = Date.now() + CONFIG.bonusProblem.averageIntervalMs + variance;
            if (nextBonusTime - Date.now() < CONFIG.bonusProblem.minIntervalMs) {
                nextBonusTime = Date.now() + CONFIG.bonusProblem.minIntervalMs;
            }
        }
        
        function showBonusProblem() {
            bonusProblemData = generateProblemForCategory(Math.min(unlockedCategories - 1, 15));
            bonusEndTime = Date.now() + CONFIG.bonusProblem.durationMs;
            
            const effects = ['doubleComps', 'facilityBoost', 'solveBoost'];
            bonusProblemData.effect = effects[Math.floor(Math.random() * effects.length)];
            
            let rewardText = '';
            if (bonusProblemData.effect === 'doubleComps') rewardText = '2√ó comps';
            else if (bonusProblemData.effect === 'facilityBoost') rewardText = '5√ó speed 2min';
            else rewardText = '10√ó solve 1min';
            
            const popup = document.getElementById('bonusProblem');
            popup.style.left = (15 + Math.random() * 70) + '%';
            popup.style.top = (15 + Math.random() * 70) + '%';
            
            document.getElementById('bonusProblemText').textContent = bonusProblemData.text;
            document.getElementById('bonusReward').textContent = rewardText;
            popup.classList.remove('hidden');
            document.getElementById('bonusInput').value = '';
            document.getElementById('bonusInput').focus();
            
            playBonus();
        }
        
        function hideBonusProblem() {
            bonusProblemData = null;
            document.getElementById('bonusProblem').classList.add('hidden');
            document.getElementById('answerInput').focus();
            scheduleNextBonus();
        }
        
        function applyBonusEffect(effect) {
            if (effect === 'doubleComps') {
                computations *= 2;
            } else if (effect === 'facilityBoost') {
                facilityBoostActive = true;
                facilityBoostEnd = Date.now() + CONFIG.bonusProblem.effects.facilityBoost.durationMs;
            } else if (effect === 'solveBoost') {
                solveBoostActive = true;
                solveBoostEnd = Date.now() + CONFIG.bonusProblem.effects.solveBoost.durationMs;
            }
        }
        
        function checkStageUp() {
            const maxStages = 63;
            const nextThreshold = getStageThreshold(currentStage + 1);
            if (totalSolved >= nextThreshold && currentStage < maxStages) {
                currentStage++;
                unlockedCategories = currentStage;
                playStageUp();
                showStageFlash();
                updateVisualFlair();
            }
        }
        
        function showStageFlash() {
            const flash = document.getElementById('stageFlash');
            flash.textContent = getEraName() + ' STAGE ' + currentStage;
            flash.classList.remove('hidden');
            flash.classList.add('show');
            setTimeout(() => {
                flash.classList.remove('show');
                setTimeout(() => flash.classList.add('hidden'), 500);
            }, 1500);
        }
        
        function updateVisualFlair() {
            const body = document.body;
            body.className = 'era-' + getEra();
            
            if (currentStage >= 5) body.classList.add('stage-5-plus');
            if (currentStage >= 10) body.classList.add('stage-10-plus');
            if (currentStage >= 17) body.classList.add('stage-17-plus');
            if (currentStage >= 33) body.classList.add('stage-33-plus');
            if (currentStage >= 52) body.classList.add('stage-52-plus');
            
            const box = document.getElementById('gameBox');
            box.className = 'game-box stage-' + currentStage + ' era-' + getEra();
        }
        
        function flickerSymbols() {
            let s = '';
            const len = 2 + Math.floor(currentStage / 4);
            for (let i = 0; i < len; i++) s += symbols[Math.floor(Math.random() * symbols.length)];
            document.getElementById('symbolFlicker').textContent = s;
        }
        
        function getPrice(base, mult, count) {
            return Math.floor(base * Math.pow(mult, count));
        }
        
        function formatNumber(n) {
            if (n >= 1e21) return (n / 1e21).toFixed(2) + 'Sx';
            if (n >= 1e18) return (n / 1e18).toFixed(2) + 'Qi';
            if (n >= 1e15) return (n / 1e15).toFixed(2) + 'Q';
            if (n >= 1e12) return (n / 1e12).toFixed(2) + 'T';
            if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
            if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
            if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
            return Math.floor(n).toLocaleString();
        }
        
        function randRange(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function randSign() { return Math.random() < 0.5 ? 1 : -1; }
        function rand1or2d() { return Math.random() < 0.5 ? randRange(1, 9) : randRange(10, 99); }
        function randSignedElement() { return rand1or2d() * randSign(); }
        
        function generateProblemForCategory(cat) {
            let answer, text, type = 'simple';
            
            if (cat < 16) {
                return generateArithmeticProblem(cat);
            } else if (cat < 32) {
                return generateProbabilityProblem(cat - 16);
            } else if (cat < 51) {
                return generateLinearAlgebraProblem(cat - 32);
            } else {
                return generateMixedProblem(cat - 51);
            }
        }
        
        function generateArithmeticProblem(cat) {
            let a, b, c, answer, text;
            
            switch(cat) {
                case 0: 
                    a = randRange(1,9); b = randRange(1,9); 
                    answer = a+b; text = `${a} + ${b} =`; 
                    break;
                case 1: 
                    a = randRange(1,9); b = randRange(1, a);
                    answer = a-b; text = `${a} - ${b} =`; 
                    break;
                case 2: 
                    a = randRange(1,9); b = randRange(1,9); 
                    answer = a*b; text = `${a} √ó ${b} =`; 
                    break;
                case 3: 
                    a = randRange(10,99); b = randRange(10,99); 
                    answer = a+b; text = `${a} + ${b} =`; 
                    break;
                case 4: 
                    a = randRange(1,9); b = randRange(1,9); c = randRange(1,9);
                    if (Math.random() < 0.5) { answer = a+b-c; text = `${a} + ${b} - ${c} =`; }
                    else { answer = a-b+c; text = `${a} - ${b} + ${c} =`; }
                    break;
                case 5: 
                    a = randRange(1,9); b = randRange(10,99); 
                    if (Math.random() < 0.5) { answer = a*b; text = `${a} √ó ${b} =`; }
                    else { answer = b*a; text = `${b} √ó ${a} =`; }
                    break;
                case 6: 
                    b = randRange(2,9); answer = randRange(2,49); a = answer*b; 
                    text = `${a} √∑ ${b} =`; 
                    break;
                case 7: 
                    a = randRange(1,9); b = randRange(1,9); c = randRange(1,9);
                    const type = Math.floor(Math.random() * 4);
                    if (type === 0) { answer = a*b+c; text = `${a} √ó ${b} + ${c} =`; }
                    else if (type === 1) { answer = a*b-c; text = `${a} √ó ${b} - ${c} =`; }
                    else if (type === 2) { answer = a+b*c; text = `${a} + ${b} √ó ${c} =`; }
                    else { answer = a-b*c; text = `${a} - ${b} √ó ${c} =`; }
                    break;
                case 8: 
                    a = randRange(100,999); b = randRange(100,999); 
                    answer = a+b; text = `${a} + ${b} =`; 
                    break;
                case 9: 
                    a = randRange(1,9); b = randRange(100,999); 
                    if (Math.random() < 0.5) { answer = a*b; text = `${a} √ó ${b} =`; }
                    else { answer = b*a; text = `${b} √ó ${a} =`; }
                    break;
                case 10: 
                    a = randRange(100,999); b = randRange(100, a); 
                    answer = a-b; text = `${a} - ${b} =`; 
                    break;
                case 11: 
                    b = randRange(2,9); answer = randRange(100,999); a = answer*b; 
                    text = `${a} √∑ ${b} =`; 
                    break;
                case 12: 
                    a = randRange(1,9); b = randRange(10,99); c = randRange(1,9);
                    if (Math.random() < 0.5) {
                        let res = randRange(2, 20); b = randRange(2,9); a = res*b;
                        answer = res + c; text = `${a} √∑ ${b} + ${c} =`;
                    } else {
                        answer = a*b - c; text = `${a} √ó ${b} - ${c} =`;
                    }
                    break;
                case 13: 
                    a = randRange(10,99); b = randRange(10,99); 
                    answer = a*b; text = `${a} √ó ${b} =`; 
                    break;
                case 14: 
                    a = randRange(10,99); b = randRange(10,99); c = randRange(10,99);
                    const t = Math.floor(Math.random() * 3);
                    if (t === 0) { answer = a*b+c; text = `${a} √ó ${b} + ${c} =`; }
                    else if (t === 1) { answer = a+b*c; text = `${a} + ${b} √ó ${c} =`; }
                    else { answer = a+b+c; text = `${a} + ${b} + ${c} =`; }
                    break;
                case 15: 
                    a = randRange(1000,9999); b = randRange(1000,9999); 
                    answer = a+b; text = `${a} + ${b} =`; 
                    break;
                default: 
                    return generateArithmeticProblem(0);
            }
            return { answer: String(answer), text, type: 'simple', category: cat };
        }
        
        function generateProbabilityProblem(cat) {
            let answer, text;
            let a, b, c, pA, pB, pAB;
            
            switch(cat) {
                case 0:
                    a = randRange(1, 9) / 10;
                    b = randRange(1, 9) / 10;
                    answer = (a + b).toFixed(2).replace(/\.?0+$/, '');
                    if (answer.indexOf('.') === -1 && a + b < 1) answer = (a + b).toFixed(1);
                    text = `${a.toFixed(1)} + ${b.toFixed(1)} =`;
                    break;
                case 1:
                    a = randRange(2, 9) / 10;
                    b = randRange(1, Math.floor(a * 10)) / 10;
                    answer = (a - b).toFixed(2).replace(/\.?0+$/, '');
                    if (answer === '0') answer = '0';
                    text = `${a.toFixed(1)} - ${b.toFixed(1)} =`;
                    break;
                case 2:
                    a = randRange(1, 9) / 10;
                    b = randRange(1, 9) / 10;
                    answer = (a * b).toFixed(2);
                    text = `${a.toFixed(1)} √ó ${b.toFixed(1)} =`;
                    break;
                case 3:
                    a = randRange(2, 9) / 10;
                    b = randRange(1, 9) / 10;
                    while (b >= a) b = randRange(1, 9) / 10;
                    answer = (a / b).toFixed(2);
                    text = `${a.toFixed(1)} √∑ ${b.toFixed(1)} =`;
                    break;
                case 4:
                    a = randRange(10, 99) / 100;
                    b = randRange(10, 99) / 100;
                    answer = (a + b).toFixed(2);
                    text = `${a.toFixed(2)} + ${b.toFixed(2)} =`;
                    break;
                case 5:
                    a = randRange(10, 99) / 100;
                    b = randRange(10, Math.floor(a * 100)) / 100;
                    answer = (a - b).toFixed(2);
                    text = `${a.toFixed(2)} - ${b.toFixed(2)} =`;
                    break;
                case 6:
                    a = randRange(10, 99) / 100;
                    b = randRange(10, 99) / 100;
                    answer = (a * b).toFixed(2);
                    text = `${a.toFixed(2)} √ó ${b.toFixed(2)} =`;
                    break;
                case 7:
                    pA = randRange(1, 9) / 10;
                    pB = randRange(1, 9) / 10;
                    answer = (pA * pB).toFixed(2);
                    text = `P(A)=${pA.toFixed(1)}, P(B)=${pB.toFixed(1)}, P(A‚à©B)=`;
                    break;
                case 8:
                    pA = randRange(1, 4) / 10;
                    pB = randRange(1, 4) / 10;
                    answer = (pA + pB).toFixed(2).replace(/\.?0+$/, '');
                    text = `P(A)=${pA.toFixed(1)}, P(B)=${pB.toFixed(1)}, P(A‚à™B)=`;
                    break;
                case 9:
                    pA = randRange(10, 90) / 100;
                    answer = (1 - pA).toFixed(2);
                    text = `P(A)=${pA.toFixed(2)}, P(¬¨A)=`;
                    break;
                case 10:
                    pA = randRange(10, 50) / 100;
                    pB = randRange(10, 50) / 100;
                    pAB = randRange(5, Math.min(Math.floor(pA * 100), Math.floor(pB * 100))) / 100;
                    answer = ((pA + pB - pAB)).toFixed(2);
                    text = `P(A)=${pA.toFixed(2)}, P(B)=${pB.toFixed(2)}, P(A‚à©B)=${pAB.toFixed(2)}, P(A‚à™B)=`;
                    break;
                case 11:
                    pAB = randRange(10, 40) / 100;
                    pB = randRange(Math.floor(pAB * 100) + 10, 90) / 100;
                    answer = (pAB / pB).toFixed(2);
                    text = `P(A‚à©B)=${pAB.toFixed(2)}, P(B)=${pB.toFixed(2)}, P(A|B)=`;
                    break;
                case 12:
                    a = randRange(1, 9) / 10;
                    b = randRange(1, 9) / 10;
                    c = randRange(1, 9) / 10;
                    const op = Math.random() < 0.5 ? '+' : '-';
                    if (op === '+') {
                        answer = (a + b * c).toFixed(2);
                        text = `${a.toFixed(1)} + ${b.toFixed(1)} √ó ${c.toFixed(1)} =`;
                    } else {
                        answer = (a - b * c).toFixed(2);
                        text = `${a.toFixed(1)} - ${b.toFixed(1)} √ó ${c.toFixed(1)} =`;
                    }
                    break;
                case 13:
                    pA = randRange(1, 5) / 10;
                    const pBA = randRange(5, 9) / 10;
                    const pBnotA = randRange(1, 3) / 10;
                    const pB_total = pBA * pA + pBnotA * (1 - pA);
                    answer = ((pBA * pA) / pB_total).toFixed(2);
                    text = `P(A)=${pA.toFixed(1)}, P(B|A)=${pBA.toFixed(1)}, P(B|¬¨A)=${pBnotA.toFixed(1)}, P(A|B)=`;
                    break;
                case 14:
                    const v1 = randRange(1, 6);
                    const v2 = randRange(1, 6);
                    const p1 = 0.5;
                    answer = (v1 * p1 + v2 * (1 - p1)).toFixed(2).replace(/\.?0+$/, '');
                    text = `E[X]: ${v1} w/ p=0.5, ${v2} w/ p=0.5 =`;
                    break;
                case 15:
                    const vals = [randRange(1, 5), randRange(2, 8), randRange(3, 10)];
                    const probs = [0.3, 0.5, 0.2];
                    const ev = vals[0] * probs[0] + vals[1] * probs[1] + vals[2] * probs[2];
                    answer = ev.toFixed(2);
                    text = `E[X]: ${vals[0]}√ó0.3 + ${vals[1]}√ó0.5 + ${vals[2]}√ó0.2 =`;
                    break;
                default:
                    return generateProbabilityProblem(0);
            }
            return { answer, text, type: 'decimal', category: cat + 16 };
        }
        
        function generateLinearAlgebraProblem(cat) {
            let answer, text, type = 'simple', inputCount = 1;
            
            const e = () => randSignedElement();
            
            switch(cat) {
                case 0: {
                    const a = e(), b = e(), c = e(), d = e();
                    answer = [a + c, b + d];
                    text = `[${a}, ${b}] + [${c}, ${d}] =`;
                    type = 'vector2';
                    inputCount = 2;
                    break;
                }
                case 1: {
                    const a = e(), b = e(), c = e(), d = e();
                    answer = [a - c, b - d];
                    text = `[${a}, ${b}] - [${c}, ${d}] =`;
                    type = 'vector2';
                    inputCount = 2;
                    break;
                }
                case 2: {
                    const k = randRange(2, 9) * randSign();
                    const a = e(), b = e();
                    answer = [k * a, k * b];
                    text = `${k} √ó [${a}, ${b}] =`;
                    type = 'vector2';
                    inputCount = 2;
                    break;
                }
                case 3: {
                    const a = e(), b = e(), c = e();
                    const d = e(), f = e(), g = e();
                    answer = [a + d, b + f, c + g];
                    text = `[${a}, ${b}, ${c}] + [${d}, ${f}, ${g}] =`;
                    type = 'vector3';
                    inputCount = 3;
                    break;
                }
                case 4: {
                    const k1 = randRange(1, 5) * randSign();
                    const k2 = randRange(1, 5) * randSign();
                    const a = e(), b = e(), c = e(), d = e();
                    answer = [k1 * a + k2 * c, k1 * b + k2 * d];
                    text = `${k1}[${a}, ${b}] + ${k2}[${c}, ${d}] =`;
                    type = 'vector2';
                    inputCount = 2;
                    break;
                }
                case 5: {
                    const k = randRange(2, 9) * randSign();
                    const a = e(), b = e(), c = e();
                    answer = [k * a, k * b, k * c];
                    text = `${k} √ó [${a}, ${b}, ${c}] =`;
                    type = 'vector3';
                    inputCount = 3;
                    break;
                }
                case 6: {
                    const a = e(), b = e(), c = e(), d = e();
                    answer = [a * c + b * d];
                    text = `[${a}, ${b}] ¬∑ [${c}, ${d}] =`;
                    type = 'simple';
                    break;
                }
                case 7: {
                    const a = e(), b = e(), c = e();
                    const d = e(), f = e(), g = e();
                    answer = [a - d, b - f, c - g];
                    text = `[${a}, ${b}, ${c}] - [${d}, ${f}, ${g}] =`;
                    type = 'vector3';
                    inputCount = 3;
                    break;
                }
                case 8: {
                    const m = [[randRange(1,5)*randSign(), randRange(1,5)*randSign()], 
                               [randRange(1,5)*randSign(), randRange(1,5)*randSign()]];
                    const v = [randRange(1,9)*randSign(), randRange(1,9)*randSign()];
                    answer = [m[0][0]*v[0] + m[0][1]*v[1], m[1][0]*v[0] + m[1][1]*v[1]];
                    text = 'matrix';
                    type = 'vector2';
                    inputCount = 2;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [m], vectors: [v], op: '√ó' };
                }
                case 9: {
                    const a = e(), b = e(), c = e();
                    const d = e(), f = e(), g = e();
                    answer = [a * d + b * f + c * g];
                    text = `[${a}, ${b}, ${c}] ¬∑ [${d}, ${f}, ${g}] =`;
                    type = 'simple';
                    break;
                }
                case 10: {
                    const v1 = [e(), e(), e()];
                    const v2 = [e(), e(), e()];
                    const v3 = [e(), e(), e()];
                    answer = [v1[0]+v2[0]+v3[0], v1[1]+v2[1]+v3[1], v1[2]+v2[2]+v3[2]];
                    text = `[${v1.join(',')}] + [${v2.join(',')}] + [${v3.join(',')}] =`;
                    type = 'vector3';
                    inputCount = 3;
                    break;
                }
                case 11: {
                    const m1 = [[randRange(1,9)*randSign(), randRange(1,9)*randSign()], 
                                [randRange(1,9)*randSign(), randRange(1,9)*randSign()]];
                    const m2 = [[randRange(1,9)*randSign(), randRange(1,9)*randSign()], 
                                [randRange(1,9)*randSign(), randRange(1,9)*randSign()]];
                    answer = [[m1[0][0]+m2[0][0], m1[0][1]+m2[0][1]], 
                              [m1[1][0]+m2[1][0], m1[1][1]+m2[1][1]]];
                    text = 'matrix';
                    type = 'matrix2x2';
                    inputCount = 4;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [m1, m2], op: '+' };
                }
                case 12: {
                    const m = [];
                    for (let i = 0; i < 3; i++) m.push([randRange(1,4)*randSign(), randRange(1,4)*randSign(), randRange(1,4)*randSign()]);
                    const v = [randRange(1,5)*randSign(), randRange(1,5)*randSign(), randRange(1,5)*randSign()];
                    answer = [
                        m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2],
                        m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2],
                        m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2]
                    ];
                    text = 'matrix';
                    type = 'vector3';
                    inputCount = 3;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [m], vectors: [v], op: '√ó' };
                }
                case 13: {
                    const a = [[randRange(1,5)*randSign(), randRange(1,5)*randSign()], 
                               [randRange(1,5)*randSign(), randRange(1,5)*randSign()]];
                    const b = [[randRange(1,5)*randSign(), randRange(1,5)*randSign()], 
                               [randRange(1,5)*randSign(), randRange(1,5)*randSign()]];
                    answer = [
                        [a[0][0]*b[0][0]+a[0][1]*b[1][0], a[0][0]*b[0][1]+a[0][1]*b[1][1]],
                        [a[1][0]*b[0][0]+a[1][1]*b[1][0], a[1][0]*b[0][1]+a[1][1]*b[1][1]]
                    ];
                    text = 'matrix';
                    type = 'matrix2x2';
                    inputCount = 4;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [a, b], op: '√ó' };
                }
                case 14: {
                    const m1 = [], m2 = [];
                    for (let i = 0; i < 3; i++) {
                        m1.push([randRange(1,5)*randSign(), randRange(1,5)*randSign(), randRange(1,5)*randSign()]);
                        m2.push([randRange(1,5)*randSign(), randRange(1,5)*randSign(), randRange(1,5)*randSign()]);
                    }
                    answer = [];
                    for (let i = 0; i < 3; i++) {
                        answer.push([m1[i][0]+m2[i][0], m1[i][1]+m2[i][1], m1[i][2]+m2[i][2]]);
                    }
                    text = 'matrix';
                    type = 'matrix3x3';
                    inputCount = 9;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [m1, m2], op: '+' };
                }
                case 15: {
                    const a = [];
                    for (let i = 0; i < 3; i++) a.push([randRange(1,4)*randSign(), randRange(1,4)*randSign()]);
                    const b = [];
                    for (let i = 0; i < 2; i++) b.push([randRange(1,4)*randSign(), randRange(1,4)*randSign(), randRange(1,4)*randSign()]);
                    answer = [];
                    for (let i = 0; i < 3; i++) {
                        answer.push([]);
                        for (let j = 0; j < 3; j++) {
                            answer[i].push(a[i][0]*b[0][j] + a[i][1]*b[1][j]);
                        }
                    }
                    text = 'matrix';
                    type = 'matrix3x3';
                    inputCount = 9;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [a, b], op: '√ó', label: '3√ó2 √ó 2√ó3' };
                }
                case 16: {
                    const a = [], b = [];
                    for (let i = 0; i < 3; i++) {
                        a.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                        b.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                    }
                    answer = [];
                    for (let i = 0; i < 3; i++) {
                        answer.push([]);
                        for (let j = 0; j < 3; j++) {
                            answer[i].push(a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j]);
                        }
                    }
                    text = 'matrix';
                    type = 'matrix3x3';
                    inputCount = 9;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [a, b], op: '√ó' };
                }
                case 17: {
                    const a = [], b = [], c = [];
                    for (let i = 0; i < 3; i++) {
                        a.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                        b.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                        c.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                    }
                    const ab = [];
                    for (let i = 0; i < 3; i++) {
                        ab.push([]);
                        for (let j = 0; j < 3; j++) {
                            ab[i].push(a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j]);
                        }
                    }
                    answer = [];
                    for (let i = 0; i < 3; i++) {
                        answer.push([ab[i][0]+c[i][0], ab[i][1]+c[i][1], ab[i][2]+c[i][2]]);
                    }
                    text = 'matrix';
                    type = 'matrix3x3';
                    inputCount = 9;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [a, b, c], ops: ['√ó', '+'] };
                }
                case 18: {
                    const a = [], b = [];
                    for (let i = 0; i < 3; i++) {
                        a.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                        b.push([randRange(1,3)*randSign(), randRange(1,3)*randSign(), randRange(1,3)*randSign()]);
                    }
                    const v = [randRange(1,4)*randSign(), randRange(1,4)*randSign(), randRange(1,4)*randSign()];
                    const ab = [];
                    for (let i = 0; i < 3; i++) {
                        ab.push([]);
                        for (let j = 0; j < 3; j++) {
                            ab[i].push(a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j]);
                        }
                    }
                    answer = [
                        ab[0][0]*v[0] + ab[0][1]*v[1] + ab[0][2]*v[2],
                        ab[1][0]*v[0] + ab[1][1]*v[1] + ab[1][2]*v[2],
                        ab[2][0]*v[0] + ab[2][1]*v[1] + ab[2][2]*v[2]
                    ];
                    text = 'matrix';
                    type = 'vector3';
                    inputCount = 3;
                    return { answer, text, type, inputCount, category: cat + 32, matrices: [a, b], vectors: [v], ops: ['√ó', '√ó'] };
                }
                default:
                    return generateLinearAlgebraProblem(0);
            }
            
            return { answer, text, type, inputCount, category: cat + 32 };
        }
        
        function generateMixedProblem(cat) {
            let answer, text, type = 'simple';
            
            switch(cat) {
                case 0: {
                    const a = randRange(2, 9);
                    const x = randRange(-20, 20);
                    const b = randRange(-50, 50);
                    const c = a * x + b;
                    answer = x;
                    text = `${a}x + ${b >= 0 ? b : '(' + b + ')'} = ${c}, x = `;
                    break;
                }
                case 1: {
                    let a, b, c, d, det;
                    do {
                        a = randRange(-5, 5); b = randRange(-5, 5);
                        c = randRange(-5, 5); d = randRange(-5, 5);
                        det = a * d - b * c;
                    } while (det === 0 || Math.abs(det) > 20 || a === 0);
                    const invA = (d / det).toFixed(2);
                    const invB = (-b / det).toFixed(2);
                    const invC = (-c / det).toFixed(2);
                    const invD = (a / det).toFixed(2);
                    answer = [invA, invB, invC, invD];
                    text = 'matrix';
                    type = 'matrix2x2';
                    return { answer, text, type, inputCount: 4, category: cat + 51, matrices: [[[a, b], [c, d]]], label: 'Inverse (2 decimals):' };
                }
                case 2: {
                    const r1 = randRange(-9, 9);
                    const r2 = randRange(-9, 9);
                    const a = 1;
                    const b = -(r1 + r2);
                    const c = r1 * r2;
                    const smaller = Math.min(r1, r2);
                    const larger = Math.max(r1, r2);
                    answer = [smaller, larger];
                    text = `x¬≤ ${b >= 0 ? '+' : ''}${b}x ${c >= 0 ? '+' : ''}${c} = 0, x = `;
                    type = 'vector2';
                    return { answer, text, type, inputCount: 2, category: cat + 51 };
                }
                case 3: {
                    const n = randRange(1, 30);
                    answer = Math.pow(2, n);
                    text = `2^${n} = `;
                    break;
                }
                case 4: {
                    let a, b, c, d, det;
                    do {
                        a = randRange(1, 5); b = randRange(-3, 3);
                        c = randRange(-3, 3); d = randRange(1, 5);
                        det = a * d - b * c;
                    } while (det === 0);
                    const b1 = randRange(-10, 10);
                    const b2 = randRange(-10, 10);
                    const x1 = (d * b1 - b * b2) / det;
                    const x2 = (-c * b1 + a * b2) / det;
                    if (Number.isInteger(x1) && Number.isInteger(x2)) {
                        answer = [x1, x2];
                        text = 'matrix';
                        type = 'vector2';
                        return { answer, text, type, inputCount: 2, category: cat + 51, matrices: [[a, b], [c, d]], vectors: [[b1], [b2]], label: 'Solve Ax=b:' };
                    }
                    return generateMixedProblem(0);
                }
                case 5: {
                    const n = randRange(10, 99);
                    answer = n * n;
                    text = `${n}¬≤ = `;
                    break;
                }
                case 6: {
                    const n = randRange(2, 20);
                    answer = n * n * n;
                    text = `${n}¬≥ = `;
                    break;
                }
                case 7: {
                    const n = randRange(4, 400);
                    const root = Math.sqrt(n);
                    answer = root.toFixed(2);
                    text = `‚àö${n} = `;
                    type = 'decimal';
                    break;
                }
                case 8: {
                    const divisor = randRange(10, 99);
                    const quotient = randRange(10, 99);
                    const dividend = divisor * quotient;
                    answer = quotient;
                    text = `${dividend} √∑ ${divisor} = `;
                    break;
                }
                case 9: {
                    const a = randRange(10, 50);
                    const b = randRange(10, 50);
                    answer = a * a + b * b;
                    text = `${a}¬≤ + ${b}¬≤ = `;
                    break;
                }
                case 10: {
                    const bases = [2, 3, 4, 5, 6, 7];
                    const a = bases[Math.floor(Math.random() * bases.length)];
                    const b = randRange(2, a <= 3 ? 6 : 4);
                    answer = Math.pow(a, b);
                    text = `${a}^${b} = `;
                    break;
                }
                case 11: {
                    const n = randRange(1, 8);
                    let fact = 1;
                    for (let i = 2; i <= n; i++) fact *= i;
                    answer = fact;
                    text = `${n}! = `;
                    break;
                }
                default:
                    return generateMixedProblem(cat % 12);
            }
            return { answer: String(answer), text, type, category: cat + 51 };
        }
        
        function generateProblem() {
            const cat = Math.floor(Math.random() * unlockedCategories);
            return generateProblemForCategory(cat);
        }
        
        function renderMatrixVisual(m) {
            const rows = m.length;
            const cols = m[0].length;
            let html = '<div class="matrix-visual cols-' + cols + '">';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    html += '<div class="matrix-visual-cell">' + m[i][j] + '</div>';
                }
            }
            html += '</div>';
            return html;
        }
        
        function renderVectorVisual(v) {
            let html = '<div class="matrix-visual cols-1">';
            for (let i = 0; i < v.length; i++) {
                html += '<div class="matrix-visual-cell">' + v[i] + '</div>';
            }
            html += '</div>';
            return html;
        }
        
        function showCurrentProblem() {
            if (!currentProblem) return;
            
            const problemText = document.getElementById('problemText');
            const matrixArea = document.getElementById('matrixInputArea');
            const simpleInput = document.getElementById('answerInput');
            
            if (currentProblem.type === 'simple' || currentProblem.type === 'decimal') {
                problemText.textContent = currentProblem.text;
                matrixArea.classList.add('hidden');
                simpleInput.classList.remove('hidden');
                simpleInput.value = '';
                simpleInput.focus();
                matrixInputs = [];
            } else {
                simpleInput.classList.add('hidden');
                matrixArea.classList.remove('hidden');
                matrixArea.innerHTML = '';
                matrixInputs = [];
                currentInputIndex = 0;
                
                if (currentProblem.matrices || currentProblem.vectors) {
                    let displayHtml = '<div class="matrix-display">';
                    const matrices = currentProblem.matrices || [];
                    const vectors = currentProblem.vectors || [];
                    const ops = currentProblem.ops || (currentProblem.op ? [currentProblem.op] : []);
                    
                    let opIdx = 0;
                    for (let i = 0; i < matrices.length; i++) {
                        const m = matrices[i];
                        if (Array.isArray(m[0])) {
                            displayHtml += renderMatrixVisual(m);
                        } else {
                            displayHtml += renderVectorVisual(m);
                        }
                        if (opIdx < ops.length && (i < matrices.length - 1 || vectors.length > 0)) {
                            displayHtml += '<span class="matrix-op">' + ops[opIdx] + '</span>';
                            opIdx++;
                        }
                    }
                    for (let i = 0; i < vectors.length; i++) {
                        const v = vectors[i];
                        if (Array.isArray(v[0])) {
                            displayHtml += renderVectorVisual(v.map(row => row[0]));
                        } else {
                            displayHtml += renderVectorVisual(v);
                        }
                        if (opIdx < ops.length && i < vectors.length - 1) {
                            displayHtml += '<span class="matrix-op">' + ops[opIdx] + '</span>';
                            opIdx++;
                        }
                    }
                    displayHtml += '<span class="matrix-op">=</span>';
                    displayHtml += '</div>';
                    
                    problemText.innerHTML = currentProblem.label ? currentProblem.label : '';
                    matrixArea.innerHTML = displayHtml;
                } else {
                    problemText.textContent = currentProblem.text;
                }
                
                let rows, cols;
                if (currentProblem.type === 'vector2') { rows = 1; cols = 2; }
                else if (currentProblem.type === 'vector3') { rows = 1; cols = 3; }
                else if (currentProblem.type === 'matrix2x2') { rows = 2; cols = 2; }
                else if (currentProblem.type === 'matrix3x3') { rows = 3; cols = 3; }
                
                const container = document.createElement('div');
                container.className = 'matrix-grid matrix-' + rows + 'x' + cols;
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.className = 'matrix-cell';
                        input.dataset.row = i;
                        input.dataset.col = j;
                        input.autocomplete = 'off';
                        
                        input.addEventListener('keydown', handleMatrixKeydown);
                        input.addEventListener('input', checkMatrixAnswer);
                        
                        matrixInputs.push(input);
                        container.appendChild(input);
                    }
                }
                
                matrixArea.appendChild(container);
                matrixInputs[0].focus();
            }
        }
        
        function handleMatrixKeydown(e) {
            if (e.key === 'Tab') {
                e.preventDefault();
                const idx = matrixInputs.indexOf(e.target);
                const nextIdx = (idx + 1) % matrixInputs.length;
                matrixInputs[nextIdx].focus();
                matrixInputs[nextIdx].select();
            } else if (e.key === 'Enter') {
                checkMatrixAnswer();
            }
        }
        
        function checkMatrixAnswer() {
            if (!currentProblem || currentProblem.type === 'simple' || currentProblem.type === 'decimal') return;
            
            const values = matrixInputs.map(inp => inp.value.trim());
            if (values.some(v => v === '')) return;
            
            let correct = true;
            const answer = currentProblem.answer;
            
            const isDecimalMatrix = Array.isArray(answer) && typeof answer[0] === 'string';
            
            if (currentProblem.type === 'vector2' || currentProblem.type === 'vector3') {
                for (let i = 0; i < answer.length; i++) {
                    const userVal = parseFloat(values[i]);
                    const correctVal = parseFloat(answer[i]);
                    if (isNaN(userVal) || Math.abs(userVal - correctVal) > 0.05) correct = false;
                }
            } else if (currentProblem.type === 'matrix2x2') {
                if (isDecimalMatrix) {
                    for (let i = 0; i < 4; i++) {
                        const userVal = parseFloat(values[i]);
                        const correctVal = parseFloat(answer[i]);
                        if (isNaN(userVal) || Math.abs(userVal - correctVal) > 0.05) correct = false;
                    }
                } else {
                    if (parseInt(values[0]) !== answer[0][0]) correct = false;
                    if (parseInt(values[1]) !== answer[0][1]) correct = false;
                    if (parseInt(values[2]) !== answer[1][0]) correct = false;
                    if (parseInt(values[3]) !== answer[1][1]) correct = false;
                }
            } else if (currentProblem.type === 'matrix3x3') {
                let idx = 0;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (parseInt(values[idx]) !== answer[i][j]) correct = false;
                        idx++;
                    }
                }
            }
            
            if (correct) solveProblem();
        }
        
        function updateDisplay() {
            document.getElementById('computations').textContent = formatNumber(computations);
            document.getElementById('compRate').textContent = '+' + formatNumber(getComputationsPerSecond()) + '/sec';
            document.getElementById('totalSolved').textContent = formatNumber(totalSolved);
            document.getElementById('opmDisplay').textContent = getOPM().toFixed(0);
            document.getElementById('bonusSolved').textContent = bonusSolved;
            
            document.getElementById('stageNumber').textContent = currentStage;
            document.getElementById('stageLabel').textContent = getEraName() + ' STAGE';
            const bits = Math.pow(2, Math.min(currentStage - 1, 20));
            document.getElementById('bitDisplay').textContent = formatNumber(bits) + '-bit';
            
            const currentThreshold = getStageThreshold(currentStage);
            const nextThreshold = getStageThreshold(currentStage + 1);
            const progress = currentStage >= 63 ? 100 : ((totalSolved - currentThreshold) / (nextThreshold - currentThreshold)) * 100;
            document.getElementById('stageFill').style.width = Math.min(100, progress) + '%';
            document.getElementById('stageNext').textContent = currentStage >= 63 ? 'MAX' : 'next: ' + formatNumber(nextThreshold);
            
            document.getElementById('streakFill').style.width = Math.min(100, (totalSolved % 50) * 2) + '%';
            
            const bonusRemaining = Math.max(0, Math.ceil((nextBonusTime - Date.now()) / 1000));
            const mins = Math.floor(bonusRemaining / 60);
            const secs = bonusRemaining % 60;
            document.getElementById('bonusCountdown').textContent = `~${mins}:${secs.toString().padStart(2, '0')}`;
            
            if (bonusProblemData) {
                const remaining = Math.max(0, Math.ceil((bonusEndTime - Date.now()) / 1000));
                document.getElementById('bonusTimer').textContent = remaining + 's';
            }
            
            updateActiveEffects();
            updateShopDisplay();
        }
        
        function updateActiveEffects() {
            const el = document.getElementById('activeEffects');
            let html = '';
            if (facilityBoostActive) {
                const rem = Math.ceil((facilityBoostEnd - Date.now()) / 1000);
                html += `<div class="effect-badge facility">‚ö° 5√ó (${rem}s)</div>`;
            }
            if (solveBoostActive) {
                const rem = Math.ceil((solveBoostEnd - Date.now()) / 1000);
                html += `<div class="effect-badge solve">üß† 10√ó (${rem}s)</div>`;
            }
            el.innerHTML = html;
        }
        
        function updateShopDisplay() {
            const facilityKeys = Object.keys(CONFIG.facilities);
            const upgradeKeys = Object.keys(CONFIG.upgrades);
            
            let nextUnlockedFacCount = 0;
            let nextUnlockedUpgCount = 0;
            
            facilityKeys.forEach((k) => {
                const cfg = CONFIG.facilities[k];
                const btn = document.getElementById('buy_' + k);
                if (!btn) return;
                
                const price = getPrice(cfg.basePrice, cfg.priceMultiplier, facilities[k].owned);
                const unlocked = currentStage >= cfg.unlockStage;
                const isNextUp = !unlocked && nextUnlockedFacCount < 2;
                
                if (!unlocked && !isNextUp) {
                    btn.classList.add('hidden');
                    return;
                }
                
                btn.classList.remove('hidden');
                
                if (isNextUp) {
                    nextUnlockedFacCount++;
                    btn.classList.add('locked', 'mystery');
                    document.getElementById('name_' + k).textContent = '???';
                    document.getElementById('desc_' + k).textContent = 'Unlock at stage ' + cfg.unlockStage;
                    document.getElementById('cost_' + k).textContent = '???';
                    document.getElementById('owned_' + k).textContent = '0';
                    btn.disabled = true;
                } else {
                    btn.classList.remove('mystery');
                    document.getElementById('name_' + k).textContent = cfg.name;
                    document.getElementById('desc_' + k).textContent = cfg.desc;
                    document.getElementById('cost_' + k).textContent = formatNumber(price);
                    document.getElementById('owned_' + k).textContent = facilities[k].owned;
                    btn.classList.toggle('locked', !unlocked);
                    btn.disabled = !unlocked || computations < price;
                }
            });
            
            upgradeKeys.forEach((k) => {
                const cfg = CONFIG.upgrades[k];
                const btn = document.getElementById('buy_' + k);
                if (!btn) return;
                
                const level = upgrades[k].level;
                const price = getPrice(cfg.basePrice, cfg.priceMultiplier, level);
                const unlocked = currentStage >= cfg.unlockStage;
                const maxed = level >= cfg.maxLevel;
                const isNextUp = !unlocked && nextUnlockedUpgCount < 2;
                
                if (!unlocked && !isNextUp) {
                    btn.classList.add('hidden');
                    return;
                }
                
                btn.classList.remove('hidden');
                
                if (isNextUp) {
                    nextUnlockedUpgCount++;
                    btn.classList.add('locked', 'mystery');
                    document.getElementById('uname_' + k).textContent = '???';
                    document.getElementById('udesc_' + k).textContent = 'Unlock at stage ' + cfg.unlockStage;
                    document.getElementById('cost_' + k).textContent = '???';
                    document.getElementById('level_' + k).textContent = '0';
                    btn.disabled = true;
                } else {
                    btn.classList.remove('mystery');
                    document.getElementById('uname_' + k).textContent = cfg.name;
                    document.getElementById('udesc_' + k).textContent = cfg.desc;
                    document.getElementById('cost_' + k).textContent = maxed ? 'MAX' : formatNumber(price);
                    document.getElementById('level_' + k).textContent = level;
                    btn.classList.toggle('locked', !unlocked);
                    btn.classList.toggle('maxed', maxed);
                    btn.disabled = !unlocked || maxed || computations < price;
                }
            });
        }
        
        function buyFacility(key) {
            const cfg = CONFIG.facilities[key];
            const price = getPrice(cfg.basePrice, cfg.priceMultiplier, facilities[key].owned);
            if (computations >= price && currentStage >= cfg.unlockStage) {
                computations -= price;
                facilities[key].owned++;
                playPurchase();
                flashPurchase();
                saveGame();
            }
        }
        
        function buyUpgrade(key) {
            const cfg = CONFIG.upgrades[key];
            const level = upgrades[key].level;
            const price = getPrice(cfg.basePrice, cfg.priceMultiplier, level);
            if (level < cfg.maxLevel && computations >= price && currentStage >= cfg.unlockStage) {
                computations -= price;
                upgrades[key].level++;
                playPurchase();
                flashPurchase();
                saveGame();
            }
        }
        
        function flashPurchase() {
            const box = document.getElementById('gameBox');
            box.classList.add('purchase-flash');
            setTimeout(() => box.classList.remove('purchase-flash'), 200);
        }
        
        function solveProblem() {
            if (!currentProblem) return;
            totalSolved++;
            solveTimestamps.push(Date.now());
            
            computations += getSolveValue();
            playCorrect();
            
            const simpleInput = document.getElementById('answerInput');
            simpleInput.value = '';
            simpleInput.classList.add('correct');
            setTimeout(() => simpleInput.classList.remove('correct'), 150);
            
            checkStageUp();
            
            if (queue.length > 0) { 
                currentProblem = queue.shift(); 
                showCurrentProblem(); 
                updateQueueDisplay(); 
            } else { 
                currentProblem = null; 
                document.getElementById('problemText').textContent = '...'; 
            }
            fillQueue();
            saveGame();
        }
        
        function updateQueueDisplay() {
            const el = document.getElementById('queueList');
            el.innerHTML = '';
            queue.forEach((p, i) => {
                const div = document.createElement('div');
                div.className = 'queue-item';
                div.textContent = p.text;
                div.style.opacity = 1 - (i * 0.25);
                el.appendChild(div);
            });
        }
        
        function spawnProblem() {
            const problem = generateProblem();
            if (!currentProblem) { currentProblem = problem; showCurrentProblem(); }
            else if (queue.length < CONFIG.queue.maxSize) { queue.push(problem); updateQueueDisplay(); }
        }
        
        function fillQueue() {
            while (queue.length < CONFIG.queue.maxSize) spawnProblem();
            if (!currentProblem) spawnProblem();
        }
        
        document.getElementById('answerInput').addEventListener('input', function() {
            if (!currentProblem) return;
            if (currentProblem.type === 'simple') {
                if (parseInt(this.value, 10) === parseInt(currentProblem.answer)) solveProblem();
            } else if (currentProblem.type === 'decimal') {
                const userVal = parseFloat(this.value);
                const correctVal = parseFloat(currentProblem.answer);
                if (!isNaN(userVal) && Math.abs(userVal - correctVal) < 0.005) solveProblem();
            }
        });
        
        document.getElementById('bonusInput').addEventListener('input', function() {
            if (!bonusProblemData) return;
            if (parseInt(this.value, 10) === parseInt(bonusProblemData.answer)) {
                bonusSolved++;
                playBonus();
                applyBonusEffect(bonusProblemData.effect);
                hideBonusProblem();
            }
        });
        
        function saveGame() {
            lastSaveTime = Date.now();
            const save = {
                computations, totalSolved, bonusSolved, currentStage, unlockedCategories,
                facilities: Object.fromEntries(Object.entries(facilities).map(([k,v]) => [k, v.owned])),
                upgrades: Object.fromEntries(Object.entries(upgrades).map(([k,v]) => [k, v.level])),
                facilityBoostEnd, solveBoostEnd, lastSaveTime
            };
            localStorage.setItem('computation_factory_v8', JSON.stringify(save));
        }
        
        function loadGame() {
            const saved = localStorage.getItem('computation_factory_v8');
            if (saved) {
                const s = JSON.parse(saved);
                computations = s.computations || 0;
                totalSolved = s.totalSolved || 0;
                bonusSolved = s.bonusSolved || 0;
                currentStage = s.currentStage || 1;
                unlockedCategories = s.unlockedCategories || 1;
                
                Object.keys(facilities).forEach(k => { facilities[k].owned = s.facilities?.[k] || 0; });
                Object.keys(upgrades).forEach(k => { upgrades[k].level = s.upgrades?.[k] || 0; });
                
                if (s.facilityBoostEnd > Date.now()) { facilityBoostActive = true; facilityBoostEnd = s.facilityBoostEnd; }
                if (s.solveBoostEnd > Date.now()) { solveBoostActive = true; solveBoostEnd = s.solveBoostEnd; }
                
                if (s.lastSaveTime) {
                    const offlineMs = Math.min(Date.now() - s.lastSaveTime, CONFIG.offline.maxOfflineMinutes * 60000);
                    const rate = getComputationsPerSecond();
                    const earnings = (offlineMs / 1000) * rate * CONFIG.offline.offlineEfficiency;
                    if (earnings > 1) computations += earnings;
                }
                
                updateVisualFlair();
            }
        }
        
        document.addEventListener('click', () => { if (audioCtx.state === 'suspended') audioCtx.resume(); }, { once: true });
        
        loadConfig();
    </script>
</body>
</html>
